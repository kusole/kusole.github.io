<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F26%2Fnc_linklist%2F</url>
    <content type="text"><![CDATA[链表（一）基础操作环形链表插值题目有一个整数val，如何在节点值有序的环形链表中插入一个节点值为val的节点，并且保证这个环形单链表依然有序。给定链表的信息，及元素的值A及对应的nxt指向的元素编号同时给定val，请构造出这个环形链表，并插入该值。 输入：[1,3,4,5,7],[1,2,3,4,0],2返回：{1,2,3,4,5,7} 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class InsertValue &#123;public: ListNode *insert(vector&lt;int&gt; A, vector&lt;int&gt; nxt, int val) &#123; // write code here ListNode *phead = createList(A, nxt); if (!phead) &#123; phead = new ListNode(val); phead-&gt;next = phead; return phead; &#125; ListNode *pnode = phead; while (val &gt; pnode-&gt;val) &#123; pnode = pnode-&gt;next; if (pnode == phead)break; &#125; ListNode *ptep = new ListNode(pnode-&gt;val); ptep-&gt;next = pnode-&gt;next; pnode-&gt;next = ptep; pnode-&gt;val = val; if (phead == pnode) return (pnode-&gt;val &gt; ptep-&gt;val ? ptep : phead); else return phead; &#125; ListNode *createList(const vector&lt;int&gt; &amp;val, const vector&lt;int&gt; &amp;nxt) &#123; if (val.empty() || nxt.empty() || val.size() != nxt.size()) return nullptr; ListNode *head = new ListNode(val[0]); ListNode *node = head; vector&lt;int&gt;::size_type index = 0; for (index = 0; index &lt; nxt.size(); index++) &#123; node-&gt;next = new ListNode(val[nxt[index]]); node = node-&gt;next; &#125; node-&gt;next = head-&gt;next; ListNode *p = head; head = node; delete p; return head; &#125; void printList(const ListNode *head) &#123; ListNode *p; if (head) &#123; cout &lt;&lt; head-&gt;val &lt;&lt; endl; for (p = head-&gt;next; p != head; p = p-&gt;next) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; &#125; &#125; &#125;&#125;;int main() &#123; vector&lt;int&gt; A = &#123;1, 3, 4, 5, 7&#125;; vector&lt;int&gt; nxt = &#123;1, 2, 3, 4, 0&#125;; ListNode *p = nullptr; InsertValue ins; p = ins.insert(A, nxt, 0); ins.printList(p); return 0;&#125; 注意如何在当前节点之后插入一个值： 分配一个节点，将插入值存入该节点 插入节点的next指向当前节点的next；当前节点的next指向插入节点。 如何在当前节点之前插入一个值： 分配一个节点，值为当前节点的复制 新增节点的next指向当前节点的next； 当前节点的next指向新增节点，当前节点的值赋值为插入值。 循环有序链表插入问题： 如果插入值为定位在头节点之前，该值要么值最小值，要么是最大值； 如果是最大值，不需要改变头节点，如果是最小值，将头节点指针指向最小值； 删除单链表中的一个值题目给定单链表和给定值，删除单链表中的这个值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Remove &#123;public: ListNode *removeNode(ListNode *pHead, int delVal) &#123; // write code here if (!pHead)return pHead; if (pHead-&gt;val == delVal) &#123; ListNode *p = pHead-&gt;next; pHead-&gt;next=NULL; delete pHead; return p; &#125; ListNode *cur = pHead-&gt;next; ListNode *pre = pHead; while (cur != NULL) &#123; if (cur-&gt;val == delVal) &#123; pre-&gt;next = cur-&gt;next; cur-&gt;next = NULL; delete cur; break; &#125; cur = cur-&gt;next; pre = pre-&gt;next; &#125; return pHead; &#125; ListNode *createList(const vector&lt;int&gt; &amp;A) &#123; if (A.empty())return nullptr; ListNode *phead = new ListNode(A[0]); ListNode *pnode = phead; for (vector&lt;int&gt;::size_type index = 1; index &lt; A.size(); index++) &#123; ListNode *ptmp = new ListNode(A[index]); pnode-&gt;next = ptmp; pnode = ptmp; &#125; return phead; &#125; void printList(ListNode *phead) &#123; ListNode *p = phead; if (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;;int main() &#123; vector&lt;int&gt; A&#123;0, 1, 2, 3, 4&#125;; Remove R; ListNode *p = NULL; p = R.createList(A); R.printList(p); p = R.removeNode(p, 0); R.printList(p); return 0;&#125; 注意假定只能访问删除节点，不能访问删除节点的前一个节点，如何删除 如果删除节点的后一个节点不为空，则可以将后一个节点的值复制到待删除节点的值，然后将待删除节点指向后一个节点的后一个节点，删除后一个节点即可 如果删除节点为最后一个节点，则不能删除，会引起系统错误； 链表（二）习题链表的分化练习题题目对于一个链表，我们需要用一个特定阈值完成对它的分化，使得小于等于这个值的结点移到前面，大于该值的结点在后面，同时保证两类结点内部的位置关系不变。 给定一个链表的头结点head，同时给定阈值val，请返回一个链表，使小于等于它的结点在前，大于等于它的在后，保证结点值不重复。 {1,4,2,5},3{1,2,4,5} 过程 代码123456789101112131415161718192021222324252627282930313233343536class Divide &#123;public: ListNode *listDivide(ListNode *head, int val) &#123; // write code here ListNode *maxhead = NULL; ListNode *maxtail = NULL; ListNode *minhead = NULL; ListNode *mintail = NULL; ListNode *pnext = NULL; while (head) &#123; pnext = head-&gt;next; head-&gt;next = NULL; if (head-&gt;val &lt;= val) &#123; if (minhead == NULL) &#123; minhead = head; mintail = head; &#125; else &#123; mintail-&gt;next = head; mintail = head; &#125; &#125; else &#123; if(maxhead == NULL)&#123; maxhead = head; maxtail = head; &#125;else&#123; maxtail-&gt;next = head; maxtail = head; &#125; &#125; head = pnext; &#125; if(mintail !=NULL) mintail-&gt;next = maxhead; return minhead!=NULL? minhead: maxhead; &#125;&#125;; 打印两个链表的公共值题目现有两个升序链表，且链表中均无重复元素。请设计一个高效的算法，打印两个链表的公共值部分。 给定两个链表的头指针headA和headB，请返回一个vector，元素为两个链表的公共部分。请保证返回数组的升序。两个链表的元素个数均小于等于500。保证一定有公共值 {1,2,3,4,5,6,7},{2,4,6,8,10}返回：[2.4.6] 过程 如果两个链表其中有一个为空，则返回； 两个指针分别指向两个链表，如果链表1的值小于链表2的值，则链表1往后移动一个位置 如果链表2的值小于链表1的值，则链表2往后移动一个位置 如果值相等，把值存入vector，然后两个链表都往后移动一个位置。 代码1234567891011121314151617181920class Common &#123;public: vector&lt;int&gt; findCommonParts(ListNode* headA, ListNode* headB) &#123; // write code here vector&lt;int&gt; ret; ListNode* pa=headA; ListNode* pb=headB; if(pa==NULL || pb==NULL)return; while(pa!=NULL&amp;&amp;pb!=NULL)&#123; if(pa-&gt;val&lt;pb-&gt;val)pa=pa-&gt;next; else if(pa-&gt;val&gt;pb-&gt;val)pb=pb-&gt;next; else&#123; ret.push_back(pa-&gt;val); pa=pa-&gt;next; pb=pb-&gt;next; &#125; &#125; return ret; &#125;&#125;; 链表的K逆序练习题目有一个单链表，请设计一个算法，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。例如链表1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null，K=3这个例子。调整后为，3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。因为K==3，所以每三个节点之间逆序，但其中的7，8不调整，因为只有两个节点不够一组。 给定一个单链表的头指针head,同时给定K值，返回逆序后的链表的头指针。 过程 根据区间的程度K求出每一个区段的前一个值，后一个值，开始值，结束值 然后进行逆序 代码 1234567891011121314151617181920212223242526272829303132333435363738394041class KInverse &#123;public: ListNode *inverse(ListNode *head, int k) &#123; // write code here if (k &lt; 2) return head; ListNode *cur = head;//当前值，循环为每一个区段的最后一个值 ListNode *pre = NULL;//当前区间的前一个值 ListNode *start = NULL;//当前区间的开始值 ListNode *next = NULL;//当前值的下一个值，循环为每一个区段的后一个值 int count = 1; while (cur != NULL) &#123; next = cur-&gt;next;//记录当前值的下一个值，用于循环进行 if (count == k) &#123; start = pre == NULL ? head : pre-&gt;next;//如果pre为空，则start为head，否则为pre的next； head = pre == NULL ? cur : head;//如果pre为空，head为第一次逆序的头一个值，即为逆序前的最后一个值cur；否则保持head resign(pre, start, cur, next);//逆序 pre = start;//下一个区段的pre为当前区段的start； count = 0; &#125; count++; cur = next; &#125; return head; &#125; void resign(ListNode *left, ListNode *start, ListNode *end, ListNode *right) &#123; ListNode * pre = start;//pre为开始值 ListNode * cur = start-&gt;next;//cur为开始值的next； ListNode * next = NULL; while(cur != right)&#123; next = cur-&gt;next;//保存cur的next；用于循环 cur -&gt;next = pre;//当前值的下一个值为前驱节点pre pre = cur;//前驱节点调到cur cur = next; &#125; if(left != NULL)//如果存在前段区间，则将前段区间的后一个值为end； left -&gt; next = end; start-&gt;next = right;//start变为当前区段的最后一个值，next指向right； &#125;&#125; 链表指定值清除题目现在有一个单链表。链表中每个节点保存一个整数，再给定一个值val，把所有等于val的节点删掉。 给定一个单链表的头结点head，同时给定一个值val，请返回清除后的链表的头结点，保证链表中有不等于该值的其它值。请保证其他元素的相对顺序。 过程 删除前几个为指定值的节点，将头节点移动到第一个不为删除值的节点； 用pre制定为不为val的节点，cur指向pre的后一个节点，如果cur为val，则pre的next指向cur的next；否则pre指向cur； 然后cur跳为下一个； 代码 123456789101112131415161718192021222324class ClearValue &#123;public: ListNode *clear(ListNode *head, int val) &#123; // write code here while (head != NULL) &#123; if (head-&gt;val != val) &#123; break; &#125; head = head-&gt;next; &#125; ListNode *cur = head-&gt;next; ListNode *pre = head; while (cur != NULL) &#123; if (cur-&gt;val == val) &#123; pre-&gt;next = cur-&gt;next; cur = cur-&gt;next; &#125; else &#123; pre = cur; cur = cur-&gt;next; &#125; &#125; return head; &#125;&#125; 链表回文结构题目请编写一个函数，检查链表是否为回文。给定一个链表ListNode* pHead，请返回一个bool，代表链表是否为回文。 过程方法一 遍历链表，将链表的每一个元素压入到栈中； 第二次遍历链表，比较每一个值和栈中弹出值，如果遇到不相等的则不是回文 方法二 定义快慢指针， 快指针一次走两个，慢指针一次走一个，将慢指针的值压入到栈中 如果快指针的下一个值为空，则为奇数个，应该弹出一个栈顶元素 慢指针依次向后遍历，比较栈顶元素和链表值，如果遇到不相等的，则不是回文 方法三 定义快慢指针，定义快慢指针， 快指针一次走两个，慢指针一次走一个，找到中间值 将中间值往后的链表元素进行逆转 从两头往中间遍历链表，比较对应的元素，如果出现不相等的，则不是回文 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Palindrome &#123;public: bool isPalindrome(ListNode *pHead) &#123; // write code here //方法一：全部压入// stack&lt;int&gt; liststack;// ListNode *pnode = pHead;// while (pnode != NULL) &#123;// liststack.push(pnode-&gt;val);// pnode = pnode-&gt;next;// &#125;// pnode = pHead;// while (pnode != NULL) &#123;// if (liststack.top() != pnode-&gt;val) &#123;// return false;// &#125;;// liststack.pop();// pnode = pnode-&gt;next;// &#125;// return true; //方法二：快慢指针// stack&lt;int&gt; liststack;// ListNode *pslownode = pHead;// ListNode *pfastnode = pHead;// int count = 1;// while (pfastnode != NULL) &#123;// liststack.push(pslownode-&gt;val);// if (pfastnode-&gt;next == NULL)break;// if (pfastnode-&gt;next-&gt;next != NULL) &#123;// pfastnode = pfastnode-&gt;next-&gt;next;// pslownode = pslownode-&gt;next;// count++;// &#125; else// break;// &#125;// if(pfastnode-&gt;next == NULL)// liststack.pop();// pslownode = pslownode-&gt;next;// while(pslownode !=NULL)&#123;// if(pslownode-&gt;val == liststack.top())&#123;// pslownode = pslownode-&gt;next;// liststack.pop();// &#125;else return false;// &#125;// return true; //方法三：逆序指针 ListNode *pslownode = pHead; ListNode *pfastnode = pHead; ListNode *pnode = pHead; while(pfastnode&amp;&amp;pfastnode-&gt;next)&#123; pfastnode = pfastnode-&gt;next-&gt;next; pslownode = pslownode-&gt;next; &#125; ListNode *pre = NULL; while(pslownode)&#123; ListNode *temp = pslownode-&gt;next; pslownode-&gt;next = pre; pre = pslownode; pslownode = temp; &#125; while(pre)&#123; if(pre-&gt;val == pnode -&gt;val)&#123; pre= pre-&gt;next; pnode = pnode-&gt;next; &#125;else return false; &#125; return true; &#125;&#125; 链表（三）习题复杂链表的复制练习题题目输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。 过程 遍历链表，将链表复制一份 遍历节点，拿到一对拷贝，拷贝的链表的random为链表的random，找到random指向的链表，将拷贝链表的random指向链表的下一个 将两个链表分离 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(pHead == NULL)return NULL; RandomListNode* cur = pHead; RandomListNode* next = NULL; while(cur != NULL)&#123; next = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur-&gt;next-&gt;next = next; cur = next; &#125; cur = pHead; RandomListNode* curCopy = NULL; while(cur != NULL)&#123; next = cur-&gt;next-&gt;next; curCopy = cur-&gt;next; curCopy-&gt;random = cur-&gt;random != NULL ? cur-&gt;random-&gt;next : NULL; cur = next; &#125; cur = pHead; RandomListNode* res = pHead-&gt;next; while(cur != NULL)&#123; next = cur-&gt;next-&gt;next; curCopy = cur-&gt;next; cur-&gt;next = next; curCopy-&gt;next = next != NULL ? next-&gt;next : NULL; cur = next; &#125; return res; &#125;&#125;; 链表判断环题目如何判断一个单链表是否有环？有环的话返回进入环的第一个节点的值，无环的话返回-1。如果链表的长度为N，请做到时间复杂度O(N)，额外空间复杂度O(1)。 给定一个单链表的头结点head（注意另一个参数adjust为加密后的数据调整参数，方便数据设置，与本题求解无关)，请返回所求值。 过程 定义快慢指针，依次遍历，当快慢指针相等时候，则认定链表又环，如果没有相等，则没有环 如果链表有环，则将快指针指向头，慢指针从原来位置继续遍历，每一次遍历一个，知道两个指针相等，返回指针的值即可 代码123456789101112131415161718192021222324252627282930/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class ChkLoop &#123;public: int chkLoop(ListNode* head, int adjust) &#123; // write code here if(head == NULL || head-&gt;next == NULL)return -1; ListNode* pfastnode = head; ListNode* pslownode = head; while(pfastnode != NULL &amp;&amp; pfastnode-&gt;next !=NULL)&#123; pslownode = pslownode-&gt;next; pfastnode = pfastnode-&gt;next-&gt;next; if(pslownode == pfastnode)break; &#125; if(pslownode == pfastnode)&#123; pfastnode = head; while(pfastnode != pslownode)&#123; pfastnode = pfastnode-&gt;next; pslownode = pslownode-&gt;next; &#125; return pfastnode-&gt;val; &#125;else&#123; return -1; &#125; &#125;&#125;; 无环单链表相交题目现在有两个无环单链表，若两个链表的长度分别为m和n，请设计一个时间复杂度为O(n + m)，额外空间复杂度为O(1)的算法，判断这两个链表是否相交。 给定两个链表的头结点headA和headB，请返回一个bool值，代表这两个链表是否相交。保证两个链表长度小于等于500。 过程方法一 将链表A节点存入hash表中，遍历链表B，看是否存在对应B元素在hash表中存在 方法二 先遍历两个链表，求出两个链表的长度 将较长的链表先遍历长度差值，剩下两个长度相同的链表 同时遍历，如果相交，则在同一节点相遇，两节点指针相同 代码1234567891011121314151617181920212223242526272829303132333435363738394041/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class CheckIntersect &#123;public: bool chkIntersect(ListNode* headA, ListNode* headB) &#123; // write code here ListNode* pa = headA; ListNode* pb = headB; if(pa==NULL || pb == NULL)return false; int countA=0, countB=0; while(pa != NULL)&#123; pa = pa-&gt;next; countA++; &#125; while(pb != NULL)&#123; pb = pb-&gt;next; countB++; &#125; int countC = countA&gt;countB?countA-countB:countB-countA; pa=headA;pb=headB; while(countC)&#123; if(countA&gt;countB)&#123; pa=pa-&gt;next; countC--; &#125;else&#123; pb=pb-&gt;next; countC--; &#125; &#125; while(pa!=NULL&amp;&amp;pb!=NULL)&#123; if(pa == pb)return true; pa=pa-&gt;next; pb=pb-&gt;next; &#125; return false; &#125;&#125;; 有环单链表相交题目如何判断两个有环单链表是否相交？相交的话返回第一个相交的节点，不想交的话返回空。如果两个链表长度分别为N和M，请做到时间复杂度O(N+M)，额外空间复杂度O(1)。 给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。过程 先利用快慢指针分别求出两个有环链表的入环节点，如果两个入环节点相等，则返回true 从链表1的入环节点开始往下遍历，如果遇到为start1，则无相交，如果遇到start2，则相交 代码12345678910111213141516171819202122232425262728293031323334353637383940/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class ChkIntersection &#123;public: bool chkInter(ListNode* head1, ListNode* head2, int adjust0, int adjust1) &#123; // write code here ListNode* start1 = enterHuan(head1); ListNode* start2 = enterHuan(head2); if(start1 == start2)return true; ListNode* p=start1-&gt;next; while(p!=start1&amp;&amp;p!=start2) p = p-&gt;next; if(p == start2) return true; return false; &#125; ListNode* enterHuan(ListNode* head)&#123; ListNode* pfastnode=head; ListNode* pslownode=head; while(pfastnode&amp;&amp;pfastnode-&gt;next)&#123; pfastnode = pfastnode-&gt;next-&gt;next; pslownode = pslownode-&gt;next; if(pfastnode == pslownode)break; &#125; if(pfastnode == pslownode)&#123; pfastnode = head; while(pfastnode != pslownode)&#123; pfastnode = pfastnode-&gt;next; pslownode = pslownode-&gt;next; &#125; return pslownode; &#125;else&#123; return NULL; &#125; &#125;&#125;; 单链表相交题目给定两个单链表的头节点head1和head2，如何判断两个链表是否相交？相交的话返回true，不想交的话返回false。给定两个链表的头结点head1和head2(注意，另外两个参数adjust0和adjust1用于调整数据,与本题求解无关)。请返回一个bool值代表它们是否相交。 过程 判断链表是否有环，有环返回入环，无环则返回空 如果一个有环，一个无环，则不可能相交 如果两个都无环，则按照无环链表相交判断 如果两个都有环，则按照有环链表相交判断 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;*/class ChkIntersection &#123;public: bool chkInter(ListNode* head1, ListNode* head2, int adjust0, int adjust1) &#123; // write code here ListNode* p1 = chkLoop(head1); ListNode* p2 = chkLoop(head2); if((p1==NULL&amp;&amp;p2!=NULL) ||(p1!=NULL&amp;&amp;p2==NULL))return false; if(p1 == NULL &amp;&amp; p2 == NULL)return chkIntersect(head1, head2); else return chkInter(head1, head2); &#125; //判断是否有环 ListNode* chkLoop(ListNode* head) &#123; // write code here if(head == NULL || head-&gt;next == NULL)return NULL; ListNode* pfastnode = head; ListNode* pslownode = head; while(pfastnode != NULL &amp;&amp; pfastnode-&gt;next !=NULL)&#123; pslownode = pslownode-&gt;next; pfastnode = pfastnode-&gt;next-&gt;next; if(pslownode == pfastnode)break; &#125; if(pslownode == pfastnode)&#123; pfastnode = head; while(pfastnode != pslownode)&#123; pfastnode = pfastnode-&gt;next; pslownode = pslownode-&gt;next; &#125; return pfastnode; &#125;else&#123; return NULL; &#125; &#125; //无环链表相交 bool chkIntersect(ListNode* headA, ListNode* headB) &#123; // write code here ListNode* pa = headA; ListNode* pb = headB; if(pa==NULL || pb == NULL)return false; int countA=0, countB=0; while(pa != NULL)&#123; pa = pa-&gt;next; countA++; &#125; while(pb != NULL)&#123; pb = pb-&gt;next; countB++; &#125; int countC = countA&gt;countB?countA-countB:countB-countA; pa=headA;pb=headB; while(countC)&#123; if(countA&gt;countB)&#123; pa=pa-&gt;next; countC--; &#125;else&#123; pb=pb-&gt;next; countC--; &#125; &#125; while(pa!=NULL&amp;&amp;pb!=NULL)&#123; if(pa == pb)return true; pa=pa-&gt;next; pb=pb-&gt;next; &#125; return false; &#125; //有环链表是否相交 bool chkInter(ListNode* head1, ListNode* head2) &#123; // write code here ListNode* start1 = enterHuan(head1); ListNode* start2 = enterHuan(head2); if(start1 == start2)return true; ListNode* p=start1-&gt;next; while(p!=start1&amp;&amp;p!=start2) p = p-&gt;next; if(p == start2) return true; return false; &#125; ListNode* enterHuan(ListNode* head)&#123; ListNode* pfastnode=head; ListNode* pslownode=head; while(pfastnode&amp;&amp;pfastnode-&gt;next)&#123; pfastnode = pfastnode-&gt;next-&gt;next; pslownode = pslownode-&gt;next; if(pfastnode == pslownode)break; &#125; if(pfastnode == pslownode)&#123; pfastnode = head; while(pfastnode != pslownode)&#123; pfastnode = pfastnode-&gt;next; pslownode = pslownode-&gt;next; &#125; return pslownode; &#125;else&#123; return NULL; &#125; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vim 学习笔记]]></title>
    <url>%2F2017%2F12%2F04%2Fvim%2F</url>
    <content type="text"><![CDATA[Vim 学习笔记概念什么是 vim Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。 Vim 的模式基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），插入模式（Insert mode）和底线命令模式（Last line mode）。 命令模式用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。 插入模式在命令模式下按下 i 就进入了输入模式。 在输入模式下，你可以输入文本内容。 底线命令模式在命令模式下按下 :（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 Vim 渐进学习第一级 – 存活 安装 vim 启动 vim 什么也别干！请先阅读 当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启 动Vim后，vim在 Normal 模式下。 让我们进入 Insert 模式，请按下键 i 。(注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了） 此时，你可以输入文本了，就像你用“记事本”一样。 如果你想返回 Normal 模式，请按 ESC 键。 现在，你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来： i → Insert 模式，按 ESC 回到 Normal 模式. x → 删当前光标所在的一个字符。 :wq → 存盘 + 退出 (:w 存盘, :q 退出) （注：:w 后可以跟文件名） dd → 删除当前行，并把删除的行存到剪贴板里 p → 粘贴剪贴板 推荐 hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。 :help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（注：退出帮助需要输入:q） 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。 当是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要 copy 一段文字的时候，你需要使用 Ctrl 键，比如：Ctrl-C。也就是说，Ctrl 键就好像功能键一样，当你按下了功能键 Ctrl 后，C 就不在是 C 了，而且就是一个命令或是一个快键键了，在 vim 的 Normal 模式下，所有的键都是功能键。这个你需要知道。 标记 下面的文字中，如果是 Ctrl-λ我会写成 &lt;C-λ&gt;. 以 : 开始的命令你需要输入 &lt;enter&gt;回车，例如 — 如果我写成 :q 也就是说你要输入 :q&lt;enter&gt;. 第二级 – 感觉良好上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（注：所有的命令都需要在 Normal 模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键） 各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴 （注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前） P → 粘贴 yy → 拷贝当前行当行于 ddP Undo/Redo u → undo &lt;C-r&gt; → redo 打开/保存/退出/改变文件 (Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。 第三级 – 更好，更强，更快先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。 更好下面，让我们看一下vim是怎么重复自己的：1515G . → (小数点) 可以重复上一次的命令 N&lt;command&gt; → 重复某个命令N次 下面是一个示例，找开一个文件你可以试试下面的命令： 2dd → 删除2行 3p → 粘贴文本3次 100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “ . → 重复上一个命令—— 100 “desu “. 3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). 更强你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。 NG → 到第 N 行 （注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（注：相当于1G，或 :1） G → 到最后一行。 按单词移动： w → 到下一个单词的开头。 e → 到下一个单词的结尾。 > 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（注：程序变量） > 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（注：程序语句） 下面，让我来说说最强的光标移动： % : 匹配括号移动，包括 (, {, [. （注：你需要把光标先移到括号上） * 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的。 更快你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干： &lt;start position&gt;&lt;command&gt;&lt;end position&gt; 例如 0y$ 命令意味着： 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等 （注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等） 第四级 – Vim 超能力你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。 在当前行上移动光标: 0 ^ ####fFtT,;` 0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 还有一个很有用的命令是 dt&quot; → 删除所有的内容，直到遇到双引号—— &quot;。 区域选择 &lt;action&gt;a&lt;object&gt; 或 &lt;action&gt;i&lt;object&gt;在visual 模式下，这些命令很强大，其命令格式为 &lt;action&gt;a&lt;object&gt; 和 &lt;action&gt;i&lt;object&gt; action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：&quot;、 &#39;、 )、 }、 ]。 假设你有一个字符串 (map (+) (&quot;foo&quot;)).而光标键在第一个 o的位置。 vi&quot; → 会选择 foo. va&quot; → 会选择 &quot;foo&quot;. vi) → 会选择 &quot;foo&quot;. va) → 会选择(&quot;foo&quot;). v2i) → 会选择 map (+) (&quot;foo&quot;) v2a) → 会选择 (map (+) (&quot;foo&quot;)) 块操作: &lt;C-v&gt;块操作，典型的操作： 0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC] ^ → 到行头 &lt;C-v&gt; → 开始块操作 &lt;C-d&gt; → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I-- [ESC] → I是插入，插入“--”，按ESC键来为每一行生效。 在Windows下的vim，你需要使用 &lt;C-q&gt; 而不是 &lt;C-v&gt; ，&lt;C-v&gt; 是拷贝剪贴板。 自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;在 Insert 模式下，你可以输入一个词的开头，然后按 &lt;C-p&gt;或是&lt;C-n&gt;，自动补齐功能就出现了…… 宏录制： qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 示例 在一个只有一行且这一行只有“1”的文本中，键入如下命令： 12&gt; qaYp&lt;C-a&gt;q&gt; → qa 开始录制 Yp 复制行. &lt;C-a&gt; 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,V,&lt;C-v&gt;前面，我们看到了 &lt;C-v&gt;的示例 （在Windows下应该是），我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J → 把所有的行连接起来（变成一行） &lt; 或 &gt; → 左右缩进 = → 自动给缩进 （注：这个功能相当强大，我太喜欢了） 在所有被选择的行后加上点东西： &lt;C-v&gt; 选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 分屏: :split 和 vsplit.下面是主要的命令，你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章VIM分屏。 :split → 创建分屏 (:vsplit创建垂直分屏) &lt;C-w&gt;&lt;dir&gt; : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 &lt;C-w&gt;_ (或 &lt;C-w&gt;|) : 最大化尺寸 (| 垂直分屏) &lt;C-w&gt;+ (或 &lt;C-w&gt;-) : 增加尺寸 Vim 命令 资料 简明 VIM 练级攻略 ，Vim 渐进学习内容来源于这篇文章，作为 Vim 新手，我觉得入门效果很好。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 快速指南]]></title>
    <url>%2F2017%2F12%2F04%2Fshell%2F</url>
    <content type="text"><![CDATA[Shell 快速指南12345███████╗██╗ ██╗███████╗██╗ ██╗ ██╔════╝██║ ██║██╔════╝██║ ██║ ███████╗███████║█████╗ ██║ ██║ ╚════██║██╔══██║██╔══╝ ██║ ██║ ███████║██║ ██║███████╗███████╗███████╗ 概述什么是 shellShell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。 Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 什么是 shell 脚本Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。 业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。 Shell 环境Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Shell 的解释器种类众多，常见的有： sh - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。 bash - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。 fish - 智能和用户友好的命令行 shell。 xiki - 使 shell 控制台更友好，更强大。 zsh - 功能强大的 shell 与脚本语言。 指定脚本解释器在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 所以，你应该会在 shell 中，见到诸如以下的注释： 指定 sh 解释器 1#!/bin/sh 指定 bash 解释器 1#!/bin/bash 注意 上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式： 12&gt; #!/usr/bin/env bash&gt; 这样做的好处是，系统会自动在 PATH 环境变量中查找你指定的程序（本例中的bash）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的PATH变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的bash，我们可能将其路径添加到PATH中，来“隐藏”老版本。如果直接用#!/bin/bash，那么系统会选择老版本的bash来执行脚本，如果用#!/usr/bin/env bash，则会使用新版本。 模式shell 有交互和非交互两种模式。 交互模式 简单来说，你可以将 shell 的交互模式理解为执行命令行。 看到形如下面的东西，说明shell处于交互模式下： 1user@host:~$ 接着，便可以输入一系列 Linux 命令，比如 ls，grep，cd，mkdir，rm 等等。 非交互模式 简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。 在非交互模式下，shell 从文件或者管道中读取命令并执行。 当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。 可以使用下面的命令让shell以非交互模式运行： 12sh /path/to/script.shbash /path/to/script.sh 上面的例子中，script.sh是一个包含shell解释器可以识别并执行的命令的普通文本文件，sh和bash是shell解释器程序。你可以使用任何喜欢的编辑器创建script.sh（vim，nano，Sublime Text, Atom等等）。 除此之外，你还可以通过chmod命令给文件添加可执行的权限，来直接执行脚本文件： 12chmod +x /path/to/script.sh #使脚本具有执行权限/path/to/test.sh 这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如： 12#!/bin/bashecho "Hello, world!" 上面的例子中，我们使用了一个很有用的命令echo来输出字符串到屏幕上。 Shell 编程 由于 bash 是 Linux 标准默认的 shell，可以说 bash 是 shell 编程的基础。 所以，下面将全部基于 bash 来讲解 shell 编程。 此外，本篇章主要介绍的是 shell 编程的语法，对于 linux 指令不做任何介绍。 解释器前面虽然两次提到了#! ，但是本着重要的事情说三遍的精神，这里再强调一遍： 在 shell 脚本，#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。#! 被称作shebang（也称为 Hashbang ）。 #! 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入sh, bash, python, php等。 示例： 123# 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好#!/bin/bash#!/usr/bin/env bash 注释shell 语法支持注释。注释是特殊的语句，会被 shell 解释器忽略。它们以 # 开头，到行尾结束。 示例： 123#!/bin/bash### This script will print your username.whoami Tip: 用注释来说明你的脚本是干什么的，以及为什么这样写。 变量跟许多程序设计语言一样，你可以在 bash 中创建变量。 Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。 你可以创建三种变量：局部变量，环境变量以及作为位置参数的变量。 局部变量 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。 局部变量可以用 = 声明（作为一种约定，变量名、=、变量的值之间不应该有空格），其值可以用$ 访问到。 示例： 123username="zhangpeng" ### 声明变量echo $username ### 输出变量的值unset username ### 删除变量 可以用 local 关键字声明属于某个函数的局部变量。这样声明的变量会在函数结束时消失。 1local local_var="I'm a local value" 环境变量 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。 创建它们跟创建局部变量类似，但使用的是 export 关键字。 1export global_var="I'm a global value" 常见的环境变量： 变量 描述 $HOME 当前用户的用户目录 $PATH 用分号分隔的目录列表，shell会到这些目录中查找命令 $PWD 当前工作目录 $RANDOM 0到32767之间的整数 $UID 数值类型，当前用户的用户ID $PS1 主要系统输入提示符 $PS2 次要系统输入提示符 这里 有一张更全面的 Bash 环境变量列表。 位置参数 位置参数是在调用一个函数并传给它参数时创建的变量。 位置参数变量表： 变量 描述 $0 脚本名称 $1 … $9 第1个到第9个参数列表 ${10} … ${N} 第10个到N个参数列表 $* or $@ 除了$0外的所有位置参数 $# 不包括$0在内的位置参数的个数 $FUNCNAME 函数名称（仅在函数内部有值） 示例： 在下面的例子中，位置参数为：$0=&#39;./script.sh&#39;，$1=&#39;foo&#39;，$2=&#39;bar&#39;： 1$ ./script.sh foo bar 变量可以有默认值。我们可以用如下语法来指定默认值： 123456789### 如果变量为空，赋给他们默认值: $&#123;VAR:='default'&#125;: $&#123;1:='first'&#125;echo "\$1 : " $1: $&#123;2:='second'&#125;echo "\$2 : " $2### 或者FOO=$&#123;FOO:-'default'&#125; Shell扩展扩展 发生在一行命令被分成一个个的 记号（tokens） 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。 感兴趣的话可以阅读关于shell扩展的更多细节。 大括号扩展大括号扩展让生成任意的字符串成为可能。它跟 文件名扩展 很类似，举个例子： 1echo beg&#123;i,a,u&#125;n ### begin began begun 大括号扩展还可以用来创建一个可被循环迭代的区间。 12echo &#123;0..5&#125; ### 0 1 2 3 4 5echo &#123;00..8..2&#125; ### 00 02 04 06 08 命令置换命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被1234567```bashnow=`date +%T`### ornow=$(date +%T)echo $now ### 19:08:26 算数扩展在bash中，执行算数运算是非常方便的。算数表达式必须包在$(( ))中。算数扩展的格式为： 12result=$(( ((10 + 5*3) - 7) / 2 ))echo $result ### 9 在算数表达式中，使用变量无需带上$前缀： 12345x=4y=7echo $(( x + y )) ### 11echo $(( ++x + y++ )) ### 12echo $(( x + y )) ### 13 单引号和双引号单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子： 12echo "Your home: $HOME" ### Your home: /Users/&lt;username&gt;echo 'Your home: $HOME' ### Your home: $HOME 当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用echo来输出用户的输入： 123INPUT="A string with strange whitespace."echo $INPUT ### A string with strange whitespace.echo "$INPUT" ### A string with strange whitespace. 调用第一个echo时给了它5个单独的参数 —— $INPUT 被分成了单独的词，echo在每个词之间打印了一个空格。第二种情况，调用echo时只给了它一个参数（整个$INPUT的值，包括其中的空格）。 来看一个更严肃的例子： 123FILE="Favorite Things.txt"cat $FILE ### 尝试输出两个文件: `Favorite` 和 `Things.txt`cat "$FILE" ### 输出一个文件: `Favorite Things.txt` 尽管这个问题可以通过把FILE重命名成Favorite-Things.txt来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（find, cat, 等等）呢。因此，如果输入 可能 包含空格，务必要用引号把表达式包起来。 数组跟其它程序设计语言一样，bash中的数组变量给了你引用多个值的能力。在bash中，数组下标也是从0开始，也就是说，第一个元素的下标是0。 跟数组打交道时，要注意一个特殊的环境变量IFS。IFS，全称 Input Field Separator，保存了数组中元素的分隔符。它的默认值是一个空格IFS=&#39; &#39;。 创建数组在 bash 中有好几种方法创建一个数组 12345array[0] = valarray[1] = valarray[2] = valarray=([2]=val [0]=val [1]=val)array=(val val val) 获取数组元素 获取数组的单个元素： 1echo $&#123;array[1]&#125; 获取数组的所有元素： 12echo $&#123;array[*]&#125;echo $&#123;array[@]&#125; 上面两行有很重要（也很微妙）的区别，假设某数组元素中包含空格： 123colors[0]=Redcolors[1]="Dark Green"colors[2]=Blue 为了将数组中每个元素单独一行输出，我们用内建的printf命令： 1234567printf "+ %s\n" $&#123;colors[*]&#125;# 输出：# + Red# + Dark# + Green# + Blue 为什么Desert和fig各占了一行？尝试用引号包起来： 1234printf "+ %s\n" "$&#123;colors[*]&#125;"# 输出：# + Red Dark Green Blue 现在所有的元素都跑去了一行 —— 这不是我们想要的！为了解决这个痛点，${colors[@]}闪亮登场： 123456printf "+ %s\n" "$&#123;colors[@]&#125;"# 输出：+ Red+ Dark Green+ Blue 在引号内，${colors[@]}将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。 访问数组的部分元素： 1echo $&#123;array[@]:0:2&#125; 在上面的例子中，${array[@]} 扩展为整个数组，:0:2取出了数组中从0开始，长度为2的元素。 获取数组长度1echo $&#123;#array[*]&#125; 向数组中添加元素向数组中添加元素也非常简单： 12345colors=(Yellow "$&#123;colors[@]&#125;" Pink Black)echo $&#123;colors[@]&#125;# 输出：# Yellow Red Dark Green Blue Pink Black 上面的例子中，${colors[@]} 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组colors的赋值覆盖了它原来的值。 从数组中删除元素用unset命令来从数组中删除一个元素： 12345unset colors[0]echo $&#123;colors[@]&#125;# 输出：# Red Dark Green Blue Pink Black 运算符算术运算符下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 示例： 12345678910111213141516171819202122232425262728a=10b=20echo "a=$a, b=$b"val=`expr $a + $b`echo "a + b : $val"val=`expr $a - $b`echo "a - b : $val"val=`expr $a \* $b`echo "a * b : $val"val=`expr $b / $a`echo "b / a : $val"val=`expr $b % $a`echo "b % a : $val"if [ $a == $b ]then echo "a 等于 b"fiif [ $a != $b ]then echo "a 不等于 b"fi 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ]返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ]返回 true。 示例： 123456789101112131415161718192021222324252627282930313233343536373839a=10b=20if [ $a -eq $b ]then echo "$a -eq $b : a 等于 b"else echo "$a -eq $b: a 不等于 b"fiif [ $a -ne $b ]then echo "$a -ne $b: a 不等于 b"else echo "$a -ne $b : a 等于 b"fiif [ $a -gt $b ]then echo "$a -gt $b: a 大于 b"else echo "$a -gt $b: a 不大于 b"fiif [ $a -lt $b ]then echo "$a -lt $b: a 小于 b"else echo "$a -lt $b: a 不小于 b"fiif [ $a -ge $b ]then echo "$a -ge $b: a 大于或等于 b"else echo "$a -ge $b: a 小于 b"fiif [ $a -le $b ]then echo "$a -le $b: a 小于或等于 b"else echo "$a -le $b: a 大于 b"fi 布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 示例： 1234567891011121314151617181920212223242526272829a=10b=20echo "a=$a, b=$b"if [ $a != $b ]then echo "$a != $b : a 不等于 b"else echo "$a != $b: a 等于 b"fiif [ $a -lt 100 -a $b -gt 15 ]then echo "$a 小于 100 且 $b 大于 15 : 返回 true"else echo "$a 小于 100 且 $b 大于 15 : 返回 false"fiif [ $a -lt 100 -o $b -gt 100 ]then echo "$a 小于 100 或 $b 大于 100 : 返回 true"else echo "$a 小于 100 或 $b 大于 100 : 返回 false"fiif [ $a -lt 5 -o $b -gt 100 ]then echo "$a 小于 5 或 $b 大于 100 : 返回 true"else echo "$a 小于 5 或 $b 大于 100 : 返回 false"fi 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false \ \ 逻辑的 OR `[[ $a -lt 100 $b -gt 100 ]]` 返回 true 示例： 123456789101112131415161718a=10b=20echo "a=$a, b=$b"if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then echo "返回 true"else echo "返回 false"fiif [[ $a -lt 100 || $b -gt 100 ]]then echo "返回 true"else echo "返回 false"fi 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 示例： 1234567891011121314151617181920212223242526272829303132333435a="abc"b="efg"echo "a=$a, b=$b"if [ $a = $b ]then echo "$a = $b : a 等于 b"else echo "$a = $b: a 不等于 b"fiif [ $a != $b ]then echo "$a != $b : a 不等于 b"else echo "$a != $b: a 等于 b"fiif [ -z $a ]then echo "-z $a : 字符串长度为 0"else echo "-z $a : 字符串长度不为 0"fiif [ -n $a ]then echo "-n $a : 字符串长度不为 0"else echo "-n $a : 字符串长度为 0"fiif [ $a ]then echo "$a : 字符串不为空"else echo "$a : 字符串为空"fi 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ]返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 示例： 变量 file 表示文件”/var/www/runoob/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243file="./operatorDemo.sh"if [ -r $file ]then echo "文件可读"else echo "文件不可读"fiif [ -w $file ]then echo "文件可写"else echo "文件不可写"fiif [ -x $file ]then echo "文件可执行"else echo "文件不可执行"fiif [ -f $file ]then echo "文件为普通文件"else echo "文件为特殊文件"fiif [ -d $file ]then echo "文件是个目录"else echo "文件不是个目录"fiif [ -s $file ]then echo "文件不为空"else echo "文件为空"fiif [ -e $file ]then echo "文件存在"else echo "文件不存在"fi 语句条件语句跟其它程序设计语言一样，Bash中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式。 条件表达式可以包含&amp;&amp;和||运算符，分别对应 与 和 或 。除此之外还有很多有用的表达式。 共有两个不同的条件表达式：if和case。 基元和组合表达式由[[ ]]（sh中是[ ]）包起来的表达式被称作 检测命令 或 基元。这些表达式帮助我们检测一个条件的结果。在下面的表里，为了兼容sh，我们用的是[ ]。这里可以找到有关bash中单双中括号区别的答案。 使用ifif在使用上跟其它语言相同。如果中括号里的表达式为真，那么then和fi之间的代码会被执行。fi标志着条件代码块的结束。 1234567### 写成一行if [[ 1 -eq 1 ]]; then echo "true"; fi### 写成多行if [[ 1 -eq 1 ]]; then echo "true"fi 同样，我们可以使用if..else语句，例如： 123456789### 写成一行if [[ 2 -ne 1 ]]; then echo "true"; else echo "false"; fi### 写成多行if [[ 2 -ne 1 ]]; then echo "true"else echo "false"fi 有些时候，if..else不能满足我们的要求。别忘了if..elif..else，使用起来也很方便。 示例： 1234567if [[ `uname` == "Adam" ]]; then echo "Do not eat an apple!"elif [[ `uname` == "Eva" ]]; then echo "Do not take an apple!"else echo "Apples are delicious!"fi 使用case如果你需要面对很多情况，分别要采取不同的措施，那么使用case会比嵌套的if更有用。使用case来解决复杂的条件判断，看起来像下面这样： 12345678910111213141516echo "input param: " $1case $1 in "jpg" | "jpeg") echo "It's image with jpeg extension." ;; "png") echo "It's image with png extension." ;; "gif") echo "Oh, it's a giphy!" ;; *) echo "Woops! It's not image!" ;;esac 每种情况都是匹配了某个模式的表达式。|用来分割多个模式，)用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。*代表任何不匹配以上给定模式的模式。命令块儿之间要用;;分隔。 循环语句循环其实不足为奇。跟其它程序设计语言一样，bash中的循环也是只要控制条件为真就一直迭代执行的代码块。 Bash中有四种循环：for，while，until和select。 for循环for与它在C语言中的姊妹非常像。看起来是这样： 1234for arg in elem1 elem2 ... elemNdo ### 语句done 在每次循环的过程中，arg依次被赋值为从elem1到elemN。这些值还可以是通配符或者大括号扩展。 当然，我们还可以把for循环写在一行，但这要求do之前要有一个分号，就像下面这样： 1for i in &#123;1..5&#125;; do echo $i; done 还有，如果你觉得for..in..do对你来说有点奇怪，那么你也可以像C语言那样使用for，比如： 123for (( i = 0; i &lt; 10; i++ )); do echo $idone 当我们想对一个目录下的所有文件做同样的操作时，for就很方便了。举个例子，如果我们想把所有的.bash文件移动到script文件夹中，并给它们可执行权限，我们的脚本可以这样写： 123456#!/bin/bashfor FILE in $HOME/*.bash; do mv "$FILE" "$&#123;HOME&#125;/scripts" chmod +x "$&#123;HOME&#125;/scripts/$&#123;FILE&#125;"done while循环while循环检测一个条件，只要这个条件为 真，就执行一段命令。被检测的条件跟if..then中使用的基元并无二异。因此一个while循环看起来会是这样： 1234while [[ condition ]]do ### 语句done 跟for循环一样，如果我们把do和被检测的条件写到一行，那么必须要在do之前加一个分号。 比如下面这个例子： 12345678#!/bin/bash### 0到9之间每个数的平方x=0while [[ $x -lt 10 ]]; do ### x小于10 echo $(( x * x )) x=$(( x + 1 )) ### x加1done until循环until循环跟while循环正好相反。它跟while一样也需要检测一个测试条件，但不同的是，只要该条件为 假 就一直执行循环： 123until [[ condition ]]; do ### 语句done select循环select循环帮助我们组织一个用户菜单。它的语法几乎跟for循环一致： 1234select answer in elem1 elem2 ... elemNdo ### 语句done select会打印elem1..elemN以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是$?（PS3变量）。用户的选择结果会被保存到answer中。如果answer是一个在1..N之间的数字，那么语句会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用break语句。 一个可能的实例可能会是这样： 1234567891011121314#!/bin/bashPS3="Choose the package manager: "select ITEM in bower npm gem pipdo echo -n "Enter the package name: " &amp;&amp; read PACKAGE case $ITEM in bower) bower install $PACKAGE ;; npm) npm install $PACKAGE ;; gem) gem install $PACKAGE ;; pip) pip install $PACKAGE ;; esac break ### 避免无限循环done 这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。 运行这个脚本，会得到如下输出： 12345678$ ./my_script1) bower2) npm3) gem4) pipChoose the package manager: 2Enter the package name: bash-handbook&lt;installing bash-handbook&gt; break 和 continue如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的break和continue语句来实现。它们可以在任何循环中使用。 break语句用来提前结束当前循环。 continue语句用来跳过某次迭代。 1234for (( i = 0; i &lt; 10; i++ )); do if [[ $(( i % 2 )) -eq 0 ]]; then continue; fi echo $idone 运行上面的例子，会打印出所有0到9之间的奇数。 函数在脚本中，我们可以定义并调用函数。跟其它程序设计语言类似，函数是一个代码块，但有所不同。 bash 中，函数是一个命令序列，这个命令序列组织在某个名字下面，即 函数名 。调用函数跟其它语言一样，写下函数名字，函数就会被 调用 。 我们可以这样声明函数： 12345my_func () &#123; ### 语句&#125;my_func ### 调用 my_func 我们必须在调用前声明函数。 函数可以接收参数并返回结果 —— 返回值。参数，在函数内部，跟非交互式下的脚本参数处理方式相同 —— 使用位置参数。返回值可以使用return命令 返回 。 下面这个函数接收一个名字参数，返回0，表示成功执行。 123456789101112### 带参数的函数greeting () &#123; if [[ -n $1 ]]; then echo "Hello, $1!" else echo "Hello, unknown!" fi return 0&#125;greeting Denys ### Hello, Denys!greeting ### Hello, stranger! 我们之前已经介绍过返回值。不带任何参数的return会返回最后一个执行的命令的返回值。上面的例子，return 0会返回一个成功表示执行的值，0。 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 流和重定向Bash有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。 管道给了我们创建传送带的机会，控制程序的执行成为可能。 学习如何使用这些强大的、高级的工具是非常非常重要的。 输入、输出流Bash接收输入，并以字符序列或 字符流 的形式产生输出。这些流能被重定向到文件或另一个流中。 有三个文件描述符： 代码 描述符 描述 0 stdin 标准输入 1 stdout 标准输出 2 stderr 标准错误输出 重定向重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到： Operator Description &gt; 重定向输出 &amp;&gt; 重定向输出和错误输出 &amp;&gt;&gt; 以附加的形式重定向输出和错误输出 &lt; 重定向输入 &lt;&lt; Here文档 语法 &lt;&lt;&lt; Here字符串 以下是一些使用重定向的例子： 1234567891011### ls的结果将会被写到list.txt中ls -l &gt; list.txt### 将输出附加到list.txt中ls -a &gt;&gt; list.txt### 所有的错误信息会被写到errors.txt中grep da * 2&gt; errors.txt### 从errors.txt中读取输入less &lt; errors.txt /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 Debuggingshell提供了用于debugging脚本的工具。如果我们想以debug模式运行某脚本，可以在其shebang中使用一个特殊的选项： 1#!/bin/bash options options是一些可以改变shell行为的选项。下表是一些可能对你有用的选项： Short Name Description -f noglob 禁止文件名展开（globbing） -i interactive 让脚本以 交互 模式运行 -n noexec 读取命令，但不执行（语法检查） -t — 执行完第一条命令后退出 -v verbose 在执行每条命令前，向stderr输出该命令 -x xtrace 在执行每条命令前，向stderr输出该命令以及该命令的扩展参数 举个例子，如果我们在脚本中指定了-x例如： 12345#!/bin/bash -xfor (( i = 0; i &lt; 3; i++ )); do echo $idone 这会向stdout打印出变量的值和一些其它有用的信息： 123456789101112131415$ ./my_script+ (( i = 0 ))+ (( i &lt; 3 ))+ echo 00+ (( i++ ))+ (( i &lt; 3 ))+ echo 11+ (( i++ ))+ (( i &lt; 3 ))+ echo 22+ (( i++ ))+ (( i &lt; 3 )) 有时我们需要debug脚本的一部分。这种情况下，使用set命令会很方便。这个命令可以启用或禁用选项。使用-启用选项，+禁用选项： 1234567#!/bin/bashecho "xtrace is turned off"set -xecho "xtrace is enabled"set +xecho "xtrace is turned off again" 资料 awesome-shell，shell 资源列表 awesome-bash，bash 资源列表 bash-handbook bash-guide ，bash 基本用法指南 bash-it，为你日常使用，开发以及维护 shell 脚本和自定义命令提供了一个可靠的框架 dotfiles.github.io，上面有bash和其它shell的各种dotfiles集合以及shell框架的链接 Runoob Shell 教程 最后，Stack Overflow上 bash 标签下有很多你可以学习的问题，当你遇到问题时，也是一个提问的好地方。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django_openstack_auth认证与集成方法]]></title>
    <url>%2F2017%2F11%2F13%2Fopenstackauth%2F</url>
    <content type="text"><![CDATA[开始准备安装django开发环境1.安装python3-pip和django1.1112sudo apt install python3-pipsudo python3 -m pip install django 2.建立Django工程进入需要创建工程的目录，用如下命令创建工程：1django-admin startproject netsec netsec目录下的文件结构如下：1234567netsec\ manage.py netsec\ __init__.py settings.py urls.py wsgi.py 3.建立Django应用进入需要创建工程的目录，用如下命令创建应用：1django-admin startapp openstack_netsec netsec目录下openstack_netsec目录的文件结构如下：123456789openstack_netsec\ __init__.py admin.py apps.py migrations\ __init__.py models.py tests.py views.py 安装并配置django_openstack_auth安装非常的简单：1.运行 python3 -m pip install django_openstack_auth2.添加 openstack_auth to settings.INSTALLED_APPS12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'openstack_auth', 'openstack_netsec'] 3.添加openstack_auth.backend.KeystoneBackend到settings.AUTHENTICATION_BACKENDS1AUTHENTICATION_BACKENDS = ('openstack_auth.backend.KeystoneBackend',) 4.配置 API endpoint(s) in settings.py:123OPENSTACK_HOST = "192.168.89.11"OPENSTACK_KEYSTONE_URL = "http://%s:5000/v3" % OPENSTACK_HOSTOPENSTACK_KEYSTONE_DEFAULT_ROLE = "user" 5.包含’openstack_auth.urls’到urls.py文件.1234urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^auth/', include('openstack_auth.urls')),] 编写keystone应用向导urls编写在netsec/urls.py中添加如下：123456789from openstack_auth import utilsfrom openstack_netsec import viewsurlpatterns = [ url(r'^$',views.splash, name='splash'), url(r'^admin/', admin.site.urls), url(r'^auth/', include('openstack_auth.urls')), url(r'^index/',views.index, name='index'),] r&#39;^$&#39;表示匹配到空项，即匹配127.0.0.1:8000时执行视图函数views.splashr&#39;^index/&#39;表示匹配到127.0.0.1:8000/index/时执行视图函数views.index views视图函数编写views.splash函数的编写12345678910def splash(request): if not request.user.is_authenticated(): return shortcuts.redirect('/index') response = shortcuts.redirect('/index') if 'logout_reason' in request.COOKIES: response.delete_cookie('logout_reason') if 'logout_status' in request.COOKIES: response.delete_cookie('logout_status') return response 当匹配到空白时，交由splash函数处理，首先判断用户是否已经登录过，如果没有登录过跳转到登录选择登录界面，当已经登录过，直接显示已经登录 template编写index.html123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/mobi.css/dist/mobi.min.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flex-center"&gt; &lt;div class="container"&gt; &lt;div&gt; &lt;h1 class="logo"&gt;&lt;a href="&#123;% url 'index' %&#125;"&gt;keystone 接入&lt;/a&gt;&lt;/h1&gt; &#123;% if user.is_authenticated %&#125; &lt;p&gt;你已登录，欢迎你：&lt;a href="#"&gt;&#123;&#123; user.username &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;button class="btn btn-default"&gt;&lt;a href="&#123;% url 'logout' %&#125;?next=&#123;&#123; request.path &#125;&#125;"&gt;注销登录&lt;/a&gt;&lt;/button&gt; &#123;% else %&#125; &lt;p&gt;你还没有登录，请 &lt;button class="btn btn-default"&gt;&lt;a href="&#123;% url 'login' %&#125;?next=&#123;&#123; request.path &#125;&#125;"&gt;登录&lt;/a&gt;&lt;/button&gt; &lt;/p&gt; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; login.html123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/mobi.css/dist/mobi.min.css"&gt; &lt;style&gt; .errorlist &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="flex-center"&gt; &lt;div class="container"&gt; &lt;div class="flex-center"&gt; &lt;div class="unit-1-2 unit-1-on-mobile"&gt; &lt;h3&gt;登录&lt;/h3&gt; &lt;form class="form" action="&#123;% url 'login' %&#125;" method="post"&gt; &#123;% csrf_token %&#125; &#123;% for field in form.visible_fields %&#125; &#123;&#123; field.label_tag &#125;&#125; &#123;&#123; field &#125;&#125; &#123;&#123; field.errors &#125;&#125; &#123;% endfor %&#125; &lt;button type="submit" class="btn btn-primary btn-block"&gt;登录&lt;/button&gt; &lt;input type="hidden" name="next" value="&#123;&#123; next &#125;&#125;"/&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当用户已经登录时，显示登录成功和注销登录界面，当用户没有登录时，显示登录按键，当用户点击登录按钮后，进入登录界面，登录界面由django form表格生成，action为django的login，此时要输入的由用户名和密码，当用户填写好表格后，点击登录，form自动将表单提交给django_openstack_auth中的login视图函数来处理，之后交由controller的keystone的认证机制来进行认真，认证完成后，返回给用户一个凭据token,之后的操作都需要这个凭据来进行验证。 之后的效果如下：]]></content>
      <categories>
        <category>openstack学习</category>
      </categories>
      <tags>
        <tag>dashborad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用一等函数实现设计模式]]></title>
    <url>%2F2017%2F11%2F13%2Fstrategy%2F</url>
    <content type="text"><![CDATA[案例分析：重构“策略”模式经典的“策略”模式图中的UML类图指出了“策略”模式对类的编排。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# classic_strategy.py# Strategy pattern -- classic implementation"""# BEGIN CLASSIC_STRATEGY_TESTS &gt;&gt;&gt; joe = Customer('John Doe', 0) # &lt;1&gt; &gt;&gt;&gt; ann = Customer('Ann Smith', 1100) &gt;&gt;&gt; cart = [LineItem('banana', 4, .5), # &lt;2&gt; ... LineItem('apple', 10, 1.5), ... LineItem('watermellon', 5, 5.0)] &gt;&gt;&gt; Order(joe, cart, FidelityPromo()) # &lt;3&gt; &lt;Order total: 42.00 due: 42.00&gt; &gt;&gt;&gt; Order(ann, cart, FidelityPromo()) # &lt;4&gt; &lt;Order total: 42.00 due: 39.90&gt; &gt;&gt;&gt; banana_cart = [LineItem('banana', 30, .5), # &lt;5&gt; ... LineItem('apple', 10, 1.5)] &gt;&gt;&gt; Order(joe, banana_cart, BulkItemPromo()) # &lt;6&gt; &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; long_order = [LineItem(str(item_code), 1, 1.0) # &lt;7&gt; ... for item_code in range(10)] &gt;&gt;&gt; Order(joe, long_order, LargeOrderPromo()) # &lt;8&gt; &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, cart, LargeOrderPromo()) &lt;Order total: 42.00 due: 42.00&gt;# END CLASSIC_STRATEGY_TESTS"""# BEGIN CLASSIC_STRATEGYfrom abc import ABC, abstractmethodfrom collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion.discount(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())class Promotion(ABC): # the Strategy: an Abstract Base Class @abstractmethod def discount(self, order): """Return discount as a positive dollar amount"""class FidelityPromo(Promotion): # first Concrete Strategy """5% discount for customers with 1000 or more fidelity points""" def discount(self, order): return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0class BulkItemPromo(Promotion): # second Concrete Strategy """10% discount for each LineItem with 20 or more units""" def discount(self, order): discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountclass LargeOrderPromo(Promotion): # third Concrete Strategy """7% discount for orders with 10 or more distinct items""" def discount(self, order): distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0# END CLASSIC_STRATEGY 每个具体策略都是一个类，而且都只定义了一个方法，即discount。此外，策略实例没有状态（没有实例属性）。你可能会说，它们看起来像是普通的函数。以下示例是对以上示例的重构，把具体策略换成了简单的函数，而且去掉了Promo抽象类。 Order 类和使用函数实现的折扣策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# strategy.py# Strategy pattern -- function-based implementation"""# BEGIN STRATEGY_TESTS &gt;&gt;&gt; joe = Customer('John Doe', 0) # &lt;1&gt; &gt;&gt;&gt; ann = Customer('Ann Smith', 1100) &gt;&gt;&gt; cart = [LineItem('banana', 4, .5), ... LineItem('apple', 10, 1.5), ... LineItem('watermellon', 5, 5.0)] &gt;&gt;&gt; Order(joe, cart, fidelity_promo) # &lt;2&gt; &lt;Order total: 42.00 due: 42.00&gt; &gt;&gt;&gt; Order(ann, cart, fidelity_promo) &lt;Order total: 42.00 due: 39.90&gt; &gt;&gt;&gt; banana_cart = [LineItem('banana', 30, .5), ... LineItem('apple', 10, 1.5)] &gt;&gt;&gt; Order(joe, banana_cart, bulk_item_promo) # &lt;3&gt; &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; long_order = [LineItem(str(item_code), 1, 1.0) ... for item_code in range(10)] &gt;&gt;&gt; Order(joe, long_order, large_order_promo) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, cart, large_order_promo) &lt;Order total: 42.00 due: 42.00&gt;# END STRATEGY_TESTS"""# BEGIN STRATEGYfrom collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) # &lt;1&gt; return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())# &lt;2&gt;def fidelity_promo(order): # &lt;3&gt; """5% discount for customers with 1000 or more fidelity points""" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0def bulk_item_promo(order): """10% discount for each LineItem with 20 or more units""" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountdef large_order_promo(order): """7% discount for orders with 10 or more distinct items""" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0# END STRATEGY best_promo 函数计算所有折扣， 并返回额度最大的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# strategy_best.py# Strategy pattern -- function-based implementation# selecting best promotion from static list of functions""" &gt;&gt;&gt; joe = Customer('John Doe', 0) &gt;&gt;&gt; ann = Customer('Ann Smith', 1100) &gt;&gt;&gt; cart = [LineItem('banana', 4, .5), ... LineItem('apple', 10, 1.5), ... LineItem('watermellon', 5, 5.0)] &gt;&gt;&gt; Order(joe, cart, fidelity_promo) &lt;Order total: 42.00 due: 42.00&gt; &gt;&gt;&gt; Order(ann, cart, fidelity_promo) &lt;Order total: 42.00 due: 39.90&gt; &gt;&gt;&gt; banana_cart = [LineItem('banana', 30, .5), ... LineItem('apple', 10, 1.5)] &gt;&gt;&gt; Order(joe, banana_cart, bulk_item_promo) &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; long_order = [LineItem(str(item_code), 1, 1.0) ... for item_code in range(10)] &gt;&gt;&gt; Order(joe, long_order, large_order_promo) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, cart, large_order_promo) &lt;Order total: 42.00 due: 42.00&gt;# BEGIN STRATEGY_BEST_TESTS &gt;&gt;&gt; Order(joe, long_order, best_promo) # &lt;1&gt; &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, banana_cart, best_promo) # &lt;2&gt; &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; Order(ann, cart, best_promo) # &lt;3&gt; &lt;Order total: 42.00 due: 39.90&gt;# END STRATEGY_BEST_TESTS"""from collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())def fidelity_promo(order): """5% discount for customers with 1000 or more fidelity points""" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0def bulk_item_promo(order): """10% discount for each LineItem with 20 or more units""" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountdef large_order_promo(order): """7% discount for orders with 10 or more distinct items""" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0# BEGIN STRATEGY_BESTpromos = [fidelity_promo, bulk_item_promo, large_order_promo] # &lt;1&gt;def best_promo(order): # &lt;2&gt; """Select best discount available """ return max(promo(order) for promo in promos) # &lt;3&gt;# END STRATEGY_BEST 找出模块中的全部策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# strategy_best2.py# Strategy pattern -- function-based implementation# selecting best promotion from current module globals""" &gt;&gt;&gt; joe = Customer('John Doe', 0) &gt;&gt;&gt; ann = Customer('Ann Smith', 1100) &gt;&gt;&gt; cart = [LineItem('banana', 4, .5), ... LineItem('apple', 10, 1.5), ... LineItem('watermellon', 5, 5.0)] &gt;&gt;&gt; Order(joe, cart, fidelity_promo) &lt;Order total: 42.00 due: 42.00&gt; &gt;&gt;&gt; Order(ann, cart, fidelity_promo) &lt;Order total: 42.00 due: 39.90&gt; &gt;&gt;&gt; banana_cart = [LineItem('banana', 30, .5), ... LineItem('apple', 10, 1.5)] &gt;&gt;&gt; Order(joe, banana_cart, bulk_item_promo) &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; long_order = [LineItem(str(item_code), 1, 1.0) ... for item_code in range(10)] &gt;&gt;&gt; Order(joe, long_order, large_order_promo) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, cart, large_order_promo) &lt;Order total: 42.00 due: 42.00&gt;# BEGIN STRATEGY_BEST_TESTS &gt;&gt;&gt; Order(joe, long_order, best_promo) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, banana_cart, best_promo) &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; Order(ann, cart, best_promo) &lt;Order total: 42.00 due: 39.90&gt;# END STRATEGY_BEST_TESTS"""from collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())def fidelity_promo(order): """5% discount for customers with 1000 or more fidelity points""" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0def bulk_item_promo(order): """10% discount for each LineItem with 20 or more units""" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discountdef large_order_promo(order): """7% discount for orders with 10 or more distinct items""" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0# BEGIN STRATEGY_BEST2promos = [globals()[name] for name in globals() # &lt;1&gt; if name.endswith('_promo') # &lt;2&gt; and name != 'best_promo'] # &lt;3&gt;# print(globals())# print([name for name in globals()])def best_promo(order): """Select best discount available """ return max(promo(order) for promo in promos) # &lt;4&gt;"""# BEGIN STRATEGY_BEST3promos = [func for name, func in inspect.getmembers(promotions, inspect.isfunction)]def best_promo(order): """Select best discount available """ return max(promo(order) for promo in promos)# END STRATEGY_BEST3"""# END STRATEGY_BEST2]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python装饰器学习]]></title>
    <url>%2F2017%2F11%2F13%2Fdecorate%2F</url>
    <content type="text"><![CDATA[1 装饰器初试1.1 装饰器基础知识装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象。 123@decoratedef target(): print('running target()') 上述代码和下述代码的写法一样 123def target(): print('running target()')target = decorate(target) 两种写法的最终结果一样：上述两个代码片段执行完毕后得到的target不一定是原来那个target 函数，而是decorate(target)返回的函数。 1234567def deco(func): def inner(): print('running inner()') return inner@decodef target(): print('running target()') 12target()print(target) running inner() &lt;function deco.&lt;locals&gt;.inner at 0x0000016C2B20AA60&gt; 严格来说，装饰器只是语法糖。如前所示，装饰器可以像常规的可调用对象那样调用，其参数是另一个函数。有时，这样做更方便，尤其是做元编程（在运行时改变程序的行为）时。综上，装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块时立即执行。下一节会说明。 1.2 Python何时执行装饰器装饰器的一个关键特性是， 它们在被装饰的函数定义之后立即运行。 这通常是在导入时(即 Python 加载模块时） ， 如 registration.py 模块所示。 12345678910111213141516171819202122232425262728293031# BEGIN REGISTRATIONregistry = [] # &lt;1&gt;def register(func): # &lt;2&gt; print('running register(%s)' % func) # &lt;3&gt; registry.append(func) # &lt;4&gt; return func # &lt;5&gt;@register # &lt;6&gt;def f1(): print('running f1()')@registerdef f2(): print('running f2()')def f3(): # &lt;7&gt; print('running f3()')def main(): # &lt;8&gt; print('running main()') print('registry -&gt;', registry) f1() f2() f3()if __name__=='__main__': main() # &lt;9&gt;# END REGISTRATION running register(&lt;function f1 at 0x0000016C2B20A378&gt;) running register(&lt;function f2 at 0x0000016C2B23B048&gt;) running main() registry -&gt; [&lt;function f1 at 0x0000016C2B20A378&gt;, &lt;function f2 at 0x0000016C2B23B048&gt;] running f1() running f2() running f3() 注意， register 在模块中其他函数之前运行（两次） 。 调用 register 时， 传给它的参数是被装饰的函数， 例如 。加载模块后， registry 中有两个被装饰函数的引用： f1 和 f2。 这两个函数， 以及 f3，只在 main 明确调用它们时才执行。如果导入 registration.py 模块（不作为脚本运行） ， 输出如下： 123&gt;&gt;&gt; import registrationrunning register(&lt;function f1 at 0x10063b1e0&gt;)running register(&lt;function f2 at 0x10063b268&gt;) 此时查看 registry 的值， 得到的输出如下 12&gt;&gt;&gt; registration.registry[&lt;function f1 at 0x10063b1e0&gt;, &lt;function f2 at 0x10063b268&gt;] 主要想强调， 函数装饰器在导入模块时立即执行， 而被装饰的函数只在明确调用时运行。 这突出了 Python 程序员所说的导入时和运行时之间的区别。 1.3 装饰器改进“策略”模式定义体中有函数的名称， 但是 best_promo 用来判断哪个折扣幅度最大的 promos 列表中也有函数名称。 这种重复是个问题， 因为新增策略函数后可能会忘记把它添加到 promos 列表中， 导致 best_promo 忽略新策略， 而且不报错， 为系统引入了不易察觉的缺陷。 实例 1 promos 列表中使用promotion装饰器填充 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# strategy_best4.py# Strategy pattern -- function-based implementation# selecting best promotion from list of functions# registered by a decorator""" &gt;&gt;&gt; joe = Customer('John Doe', 0) &gt;&gt;&gt; ann = Customer('Ann Smith', 1100) &gt;&gt;&gt; cart = [LineItem('banana', 4, .5), ... LineItem('apple', 10, 1.5), ... LineItem('watermellon', 5, 5.0)] &gt;&gt;&gt; Order(joe, cart, fidelity) &lt;Order total: 42.00 due: 42.00&gt; &gt;&gt;&gt; Order(ann, cart, fidelity) &lt;Order total: 42.00 due: 39.90&gt; &gt;&gt;&gt; banana_cart = [LineItem('banana', 30, .5), ... LineItem('apple', 10, 1.5)] &gt;&gt;&gt; Order(joe, banana_cart, bulk_item) &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; long_order = [LineItem(str(item_code), 1, 1.0) ... for item_code in range(10)] &gt;&gt;&gt; Order(joe, long_order, large_order) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, cart, large_order) &lt;Order total: 42.00 due: 42.00&gt;# BEGIN STRATEGY_BEST_TESTS &gt;&gt;&gt; Order(joe, long_order, best_promo) &lt;Order total: 10.00 due: 9.30&gt; &gt;&gt;&gt; Order(joe, banana_cart, best_promo) &lt;Order total: 30.00 due: 28.50&gt; &gt;&gt;&gt; Order(ann, cart, best_promo) &lt;Order total: 42.00 due: 39.90&gt;# END STRATEGY_BEST_TESTS"""from collections import namedtupleCustomer = namedtuple('Customer', 'name fidelity')class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantityclass Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, '__total'): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) return self.total() - discount def __repr__(self): fmt = '&lt;Order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;' return fmt.format(self.total(), self.due())# BEGIN STRATEGY_BEST4promos = [] # &lt;1&gt;def promotion(promo_func): # &lt;2&gt; promos.append(promo_func) return promo_func@promotion # &lt;3&gt;def fidelity(order): """5% discount for customers with 1000 or more fidelity points""" return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0@promotiondef bulk_item(order): """10% discount for each LineItem with 20 or more units""" discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discount@promotiondef large_order(order): """7% discount for orders with 10 or more distinct items""" distinct_items = &#123;item.product for item in order.cart&#125; if len(distinct_items) &gt;= 10: return order.total() * .07 return 0def best_promo(order): # &lt;4&gt; """Select best discount available """ return max(promo(order) for promo in promos)# END STRATEGY_BEST4 优点如下： 促销策略函数无需使用特殊的名称（即不用以 _promo 结尾）。 @promotion 装饰器突出了被装饰的函数的作用， 还便于临时禁用某个促销策略： 只需把装饰器注释掉。 促销折扣策略可以在其他模块中定义， 在系统中的任何地方都行， 只要使用@promotion 装饰即可。 2 闭包2.1 闭包的使用在博客圈， 人们有时会把闭包和匿名函数弄混。 这是有历史原因的： 在函数内部定义函数不常见， 直到开始使用匿名函数才会这样做。 而且， 只有涉及嵌套函数时才有闭包问题。因此， 很多人是同时知道这两个概念的。其实， 闭包指延伸了作用域的函数， 其中包含函数定义体中引用、 但是不在定义体中定义的非全局变量。 函数是不是匿名的没有关系， 关键是它能访问定义体之外定义的非全局变量。 1、闭包实现 123456789101112131415161718192021222324252627282930313233"""&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0&gt;&gt;&gt; avg.__code__.co_varnames('new_value', 'total')&gt;&gt;&gt; avg.__code__.co_freevars('series',)&gt;&gt;&gt; avg.__closure__ # doctest: +ELLIPSIS(&lt;cell at 0x...: list object at 0x...&gt;,)&gt;&gt;&gt; avg.__closure__[0].cell_contents[10, 11, 12]"""DEMO = """&gt;&gt;&gt; avg.__closure__(&lt;cell at 0x107a44f78: list object at 0x107a91a48&gt;,)"""def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager 2、初学者实现 123456789101112131415161718192021"""&gt;&gt;&gt; avg = Averager()&gt;&gt;&gt; avg(10)10.0&gt;&gt;&gt; avg(11)10.5&gt;&gt;&gt; avg(12)11.0"""class Averager(): def __init__(self): self.series = [] def __call__(self, new_value): self.series.append(new_value) total = sum(self.series) return total/len(self.series) 综上， 闭包是一种函数， 它会保留定义函数时存在的自由变量的绑定， 这样调用函数时，虽然定义作用域不可用了， 但是仍能使用那些绑定。注意， 只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。 2.2 nonloacl声明前面实现 make_averager 函数的方法效率不高。在示例中，我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值。 12345678def make_averager(): count = 0 total = 0 def averager(new_value): count += 1 total += new_value return total / count return averager 尝试使用示例定义的函数， 会得到如下结果： 123456&gt;&gt;&gt; avg = make_averager()&gt;&gt;&gt; avg(10)Traceback (most recent call last):...UnboundLocalError: local variable 'count' referenced before assignment&gt;&gt;&gt; 问题是， 当 count 是数字或任何不可变类型时， count += 1 语句的作用其实与 count= count + 1 一样。 因此， 我们在 averager 的定义体中为 count 赋值了， 这会把count 变成局部变量。 total 变量也受这个问题影响。 前面没有遇到这个问题， 因为我们没有给 series 赋值， 我们只是调用series.append， 并把它传给 sum 和 len。 也就是说， 我们利用了列表是可变的对象这一事实。但是对数字、 字符串、 元组等不可变类型来说， 只能读取， 不能更新。 如果尝试重新绑定， 例如 count = count + 1， 其实会隐式创建局部变量 count。 这样， count 就不是自由变量了， 因此不会保存在闭包中。 为了解决这个问题， Python 3 引入了 nonlocal 声明。 它的作用是把变量标记为自由变量， 即使在函数中为变量赋予新值了， 也会变成自由变量。 如果为 nonlocal 声明的变量赋予新值， 闭包中保存的绑定会更新。 最新版 make_averager 的正确实现如示例所示。 123456789def make_averager(): count = 0 total = 0 def averager(new_value): nonlocal count, total count += 1 total += new_value return total / count return averager 3 实现一个简单的装饰器 定义了一个装饰器， 它会在每次调用被装饰的函数时计时， 然后把经过的时间、 传入的参数和调用的结果打印出来。 12345678910111213# clockdeco.pyimport timedef clock(func): def clocked(*args): t0 = time.time() result = func(*args) elapsed = time.time()-t0 #闭包中包含自由变量func() name = func.__name__ arg_str = ', '.join(repr(arg) for arg in args) print('[%0.8fs] %s(%s) -&gt; $r' % \ (elapsed, name, arg_str, result)) return result return clocked #返回内部函数，取代被装饰的函数 使用clock装饰器 1234567891011121314151617# clockdeco_demo.pyimport timeimport clockdeco import clock@clockdef snooze(seconds): time.sleep(seconds)@clockdef factorial(n): return 1 if n &lt; 2 else n*factorial(n-1)if __name__ == '__main__': print('*' * 40, 'Calling snozzen(.123)') snooze(.123) print('*' * 40, 'Calling factorial(6)') factorial(6) 1234567891011$ python3 clockdeco_demo.py**************************************** Calling snooze(123)[0.12405610s] snooze(.123) -&gt; None**************************************** Calling factorial(6)[0.00000191s] factorial(1) -&gt; 1[0.00004911s] factorial(2) -&gt; 2[0.00008488s] factorial(3) -&gt; 6[0.00013208s] factorial(4) -&gt; 24[0.00019193s] factorial(5) -&gt; 120[0.00026107s] factorial(6) -&gt; 7206! = 720 这是装饰器的典型行为： 把被装饰的函数替换成新函数， 二者接受相同的参数， 而且（通常） 返回被装饰的函数本该返回的值， 同时还会做些额外操作。 示例中实现的 clock 装饰器有几个缺点：不支持关键字参数，而且遮盖了被装饰函数的 __name__ 和 __doc__ 属性。下面使用 functools.wraps 装饰器把相关的属性从 func 复制到 clocked 中。此外，这个新版还能正确处理关键字参数。 12345678910111213141516171819# clockdeco2.pyimport timeimport functoolsdef clock(func): @functions.wraps(func) def clocked(*args, **kwargs): t0 = time.time() result = func(*args) elapsed = time.time()-t0 #闭包中包含自由变量func() name = func.__name__ arg_lst = [] if args: arg_lst.append(', '.join(repr(arg) for arg in args)) if kwargs: pairs = ['%s=%r' % (k, w) for k, w in sorted(kwargs.items())] arg_lst.append(', '.join(pairs)) arg_str = ', '.join(arg_lst) print('[%0.8fs] %s(%s) -&gt; %r ' % (elapsed, name, arg_str, result)) return result 4 参数化装饰器解析源码中的装饰器时， Python 把被装饰的函数作为第一个参数传给装饰器函数。 那怎么让装饰器接受其他参数呢？ 答案是： 创建一个装饰器工厂函数， 把参数传给它， 返回一个装饰器， 然后再把它应用到要装饰的函数上。 4.1 一个参数化的注册装饰器为了便于启用或禁用 register 执行的函数注册功能， 我们为它提供一个可选active参数， 设为 False 时， 不注册被装饰的函数。 实现方式参见示例。从概念上看， 这个新的 register 函数不是装饰器， 而是装饰器工厂函数。 调用它会返回真正的装饰器，这才是应用到目标函数上的装饰器。 12345678910111213141516171819202122232425262728# BEGIN REGISTRATION_PARAMregistry = set() # &lt;1&gt;def register(active=True): # &lt;2&gt; def decorate(func): # &lt;3&gt; print('running register(active=%s)-&gt;decorate(%s)' % (active, func)) if active: # &lt;4&gt; registry.add(func) else: registry.discard(func) # &lt;5&gt; return func # &lt;6&gt; return decorate # &lt;7&gt;@register(active=False) # &lt;8&gt;def f1(): print('running f1()')@register() # &lt;9&gt;def f2(): print('running f2()')def f3(): print('running f3()')print(registry)# END REGISTRATION_PARAM 代码在 registration_param.py 模块中。 如果导入， 得到的结果如下： 12345&gt;&gt;&gt; import registration_paramrunning register(active=False)-&gt;decorate(&lt;function f1 at 0x10063c1e0&gt;)running register(active=True)-&gt;decorate(&lt;function f2 at 0x10063c268&gt;)&gt;&gt;&gt; registration_param.registry&#123;&lt;function f2 at 0x10063c268&gt;&#125; 4.2 参数化clock装饰器探讨 clock 装饰器， 为它添加一个功能： 让用户传入一个格式字符串， 控制被装饰函数的输出。 12345678910111213141516171819202122232425262728293031323334353637383940# clockdeco_param.py"""&gt;&gt;&gt; snooze(.1) # doctest: +ELLIPSIS[0.101...s] snooze(0.1) -&gt; None&gt;&gt;&gt; clock('&#123;name&#125;: &#123;elapsed&#125;')(time.sleep)(.2) # doctest: +ELLIPSISsleep: 0.20...&gt;&gt;&gt; clock('&#123;name&#125;(&#123;args&#125;) dt=&#123;elapsed:0.3f&#125;s')(time.sleep)(.2)sleep(0.2) dt=0.201s"""# BEGIN CLOCKDECO_PARAMimport timeDEFAULT_FMT = '[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'def clock(fmt=DEFAULT_FMT): # &lt;1&gt; def decorate(func): # &lt;2&gt; def clocked(*_args): # &lt;3&gt; t0 = time.time() _result = func(*_args) # &lt;4&gt; elapsed = time.time() - t0 name = func.__name__ args = ', '.join(repr(arg) for arg in _args) # &lt;5&gt; result = repr(_result) # &lt;6&gt; print(fmt.format(**locals())) # &lt;7&gt; return _result # &lt;8&gt; return clocked # &lt;9&gt; return decorate # &lt;10&gt;if __name__ == '__main__': @clock() # &lt;11&gt; def snooze(seconds): time.sleep(seconds) for i in range(3): snooze(.123)# END CLOCKDECO_PARAM 1234$ python3 clockdeco_param.py[0.12412500s] snooze(0.123) -&gt; None[0.12411904s] snooze(0.123) -&gt; None[0.12410498s] snooze(0.123) -&gt; None 使用了 clockdeco_param 模块中的新功能， 随后是两个模块输出的结果。 123456789import timefrom clockdeco_param import clock@clock('&#123;name&#125;: &#123;elapsed&#125;s')def snooze(seconds): time.sleep(seconds)for i in range(3): snooze(.123) 1234$ python3 clockdeco_param_demo1.pysnooze: 0.12414693832397461ssnooze: 0.1241159439086914ssnooze: 0.12412118911743164s]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[horizon 二次开发环境配置]]></title>
    <url>%2F2017%2F11%2F13%2Fhorizondevelop1%2F</url>
    <content type="text"><![CDATA[openstack源代码的获取我们可以从OpenStack Releases下载所有发行版本的openstack，openstack每6个月发行一个版本。选择相应的openstac版本和相应组件版本。 Horizon UI开发环境部署这里认为以及部署好一个openstack ocata基础环境，仅演示手动部署horizon ui开发环境 开发准备安装pip12sudo apt-get install python-pipsudo apt-get install -y libxml2-dev libxslt1-dev zlib1g-dev python3-pip 下载horizon源码:12git clone https://github.com/openstack/horizon.gitcd horizon/ 环境配置1cp openstack_dashboard/local/local_settings.py.example openstack_dashboard/local/local_settings.py vi openstack_dashboard/local/local_settings.py12345678910111213141516171819202122232425262728ALLOWED_HOSTS = '*'# ...OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = 'default' # 如果 Domain 的 ID 不是 default，则为对应的 ID # ...OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True# ...OPENSTACK_HOST = "192.168.89.11" # 控制节点IP地址OPENSTACK_KEYSTONE_URL = "http://%s:5000/v3" % OPENSTACK_HOSTOPENSTACK_KEYSTONE_DEFAULT_ROLE = "user" #根据你的环境自己配置这个参数，这里我是‘user’# ...OPENSTACK_API_VERSIONS = &#123; "identity": 3, "image": 2, "volume": 2,&#125;# ...# 根据你的网络环境配置这里的参数OPENSTACK_NEUTRON_NETWORK = &#123; #... 'enable_router': False, 'enable_quotas': False, 'enable_distributed_router': False, 'enable_ha_router': False, 'enable_lb': False, 'enable_firewall': False, 'enable_vpn': False, 'enable_fip_topology_check': False,&#125; django session cache选择1.依赖安装12345sudo apt-get install memcachedpip install python-memcachedsudo apt-get install python-devsudo apt-get install libmemcached-devpip install pylibmc 2.配置local_setting.py123456CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': '127.0.0.1:11211', &#125;,&#125; 设定hostsvim /etc/hosts1192.168.89.11 controller 压缩静态文件初始化静态文件 注意：一定要先执行此步骤再启动服务！否则再执行因为缓存还是不能正常运行，需要在 collectstatic 时增加 -c 参数12python manage.py collectstatic -lpython manage.py compress --force 语言环境切换1.修改horizon/openstack_dashboard/locale/zh_CN/LC_MESSAGES/django.po 注意按照下面的格式123#: templates/403.html:25 templates/404.html:24msgid "Projects"msgstr "项目" 2.编译12cd horizon/openstack_dashboarddjango-admin compilemessages 3.done 注意：以上的环境为python3.5和pip3 运行效果打开pycharm，加载运行horizon源码，选择编译器版本为python3,安装requirements.txt中的依赖，安装以上步骤配置完成后，点击运行，得到如下效果： 登录进去效果如下:]]></content>
      <categories>
        <category>openstack学习</category>
      </categories>
      <tags>
        <tag>dashborad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[初等算法]--红黑树]]></title>
    <url>%2F2017%2F07%2F28%2FbasicAlg02%2F</url>
    <content type="text"><![CDATA[红黑树的定义红黑树是一种自平衡二叉搜索树。通过对节点进行着色和旋转,红黑树可以很容易地保持树的平衡。我们需要在二叉搜索树上增加一个额外的颜色信息。节点可以被涂成红色或黑色。如果一棵二叉搜索树满足下面的全部5条性质,我们称之为红黑树。 任一节点要么是红色,要么是黑色。 根节点为黑色。 所有的叶节点(NIL节点)为黑色。 如果一个节点为红色,则它的两个子节点都是黑色。 对任一节点,从它出发到所有叶子节点的路径上包含相同数量的黑色节点。 为什么这5条性质能保证红黑树的平衡性呢?因为它们有一个关键的特性:从根节点出发到达叶节点的所有路径中,最长路径不会超过最短路径两倍。注意到第四条性质,它意味着不存在两个连续的红色节点。因此,最短的路径只含有黑色的节点,任何比最短路径长的路径上都分散有一些红色节点。根据性质五,从根节点出发的所有的路径都含有相同数量的黑色节点,这就最终保证了没有任何路径超过最短路径长度的两倍。图3.4的例子展示了一棵红黑树。红黑树沿用所有二叉搜索树中不改变树结构的操作,包括查找、获取最大、最小值等。只有插入和删除操作是特殊的。由于只增加了一个颜色信息,我们可以复用二叉搜索树的节点定义。如下面的C++代码所示:123456789enum Color &#123;Red, Black&#125;;template &lt;class T&gt;struct node &#123; Color color; T key; node* left; node* right; node* parent;&#125;;]]></content>
      <categories>
        <category>初等算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言基础--并行计算、包、测试]]></title>
    <url>%2F2017%2F07%2F06%2Fgoeasylearn3%2F</url>
    <content type="text"><![CDATA[Go并行计算如果说Go有什么让人一见钟情的特性，那大概就是并行计算了吧。 做个题目 如果我们列出10以下所有能够被3或者5整除的自然数，那么我们得到的是3，5，6和9。这四个数的和是23。那么请计算1000以下（不包括1000）的所有能够被3或者5整除的自然数的和。 这个题目的一个思路就是： (1) 先计算1000以下所有能够被3整除的整数的和A，(2) 然后计算1000以下所有能够被5整除的整数和B，(3) 然后再计算1000以下所有能够被3和5整除的整数和C，(4) 使用A+B-C就得到了最后的结果。 按照上面的方法，传统的方法当然就是一步一步计算，然后再到第(4)步汇总了。 但是一旦有了Go，我们就可以让前面三个步骤并行计算，然后再在第(4)步汇总。 并行计算涉及到一个新的数据类型chan和一个新的关键字go。 先看例子： 1234567891011121314151617181920212223242526272829303132333435package mainimport ( "fmt" "time")func get_sum_of_divisible(num int, divider int, resultChan chan int) &#123; sum := 0 for value := 0; value &lt; num; value++ &#123; if value%divider == 0 &#123; sum += value &#125; &#125; resultChan &lt;- sum&#125;func main() &#123; LIMIT := 10 resultChan := make(chan int, 3) t_start := time.Now() go get_sum_of_divisible(LIMIT, 3, resultChan) go get_sum_of_divisible(LIMIT, 5, resultChan) //这里其实那个是被3整除，哪个是被5整除看具体调度方法，不过由于是求和，所以没关系 sum3, sum5 := &lt;-resultChan, &lt;-resultChan //单独算被15整除的 go get_sum_of_divisible(LIMIT, 15, resultChan) sum15 := &lt;-resultChan sum := sum3 + sum5 - sum15 t_end := time.Now() fmt.Println(sum) fmt.Println(t_end.Sub(t_start))&#125; (1) 在上面的例子中，我们首先定义了一个普通的函数get_sum_of_divisible，这个函数的最后一个参数是一个整型chan类型，这种类型，你可以把它当作一个先进先出的队列。你可以向它写入数据，也可以从它读出数据。它所能接受的数据类型就是由chan关键字后面的类型所决定的。在上面的例子中，我们使用&lt;-运算符将函数计算的结果写入channel。channel是go提供的用来协程之间通信的方式。本例中main是一个协程，三个get_sum_of_divisible调用是协程。要在这四个协程间通信，必须有一种可靠的手段。 (2) 在main函数中，我们使用go关键字来开启并行计算。并行计算是由goroutine来支持的，goroutine又叫做协程，你可以把它看作为比线程更轻量级的运算。开启一个协程很简单，就是go关键字后面跟上所要运行的函数。 (3) 最后，我们要从channel中取出并行计算的结果。使用&lt;-运算符从channel里面取出数据。 在本例中，我们为了演示go并行计算的速度，还引进了time包来计算程序执行时间。在同普通的顺序计算相比，并行计算的速度是非同凡响的。 好了，上面的例子看完，我们来详细讲解Go的并行计算。 Go Routine 协程所谓协程，就是Go提供的轻量级的独立运算过程，比线程还轻。创建一个协程很简单，就是go关键字加上所要运行的函数。看个例子：1234567891011121314package mainimport ( "fmt")func list_elem(n int) &#123; for i := 0; i &lt; n; i++ &#123; fmt.Println(i) &#125;&#125;func main() &#123; go list_elem(10)&#125; 上面的例子是创建一个协程遍历一下元素。但是当你运行的时候，你会发现什么都没有输出！为什么呢？因为上面的main函数在创建完协程后就立刻退出了，所以协程还没有来得及运行呢！修改一下：12345678910111213141516package mainimport ( "fmt")func list_elem(n int) &#123; for i := 0; i &lt; n; i++ &#123; fmt.Println(i) &#125;&#125;func main() &#123; go list_elem(10) var input string fmt.Scanln(&amp;input)&#125; 这里，我们在main函数创建协程后，要求用户输入任何数据后才退出，这样协程就有了运行的时间，故而输出结果：123456789100123456789 其实在开头的例子里面，我们的main函数事实上也被阻塞了，因为sum3, sum5, sum15 := &lt;-resultChan, &lt;-resultChan, &lt;-resultChan这行代码在channel里面没有数据或者数据个数不符的时候，都会阻塞在那里，直到协程结束，写入结果。 不过既然是并行计算，我们还是得看看协程是否真的并行计算了。123456789101112131415161718192021package mainimport ( "fmt" "math/rand" "time")func list_elem(n int, tag string) &#123; for i := 0; i &lt; n; i++ &#123; fmt.Println(tag, i) tick := time.Duration(rand.Intn(100)) time.Sleep(time.Millisecond * tick) &#125;&#125;func main() &#123; go list_elem(10, "go_a") go list_elem(20, "go_b") var input string fmt.Scanln(&amp;input)&#125; 输出结果123456789101112131415161718192021222324252627282930go_a 0go_b 0go_a 1go_b 1go_a 2go_b 2go_b 3go_b 4go_a 3go_b 5go_b 6go_a 4go_a 5go_b 7go_a 6go_a 7go_b 8go_b 9go_a 8go_b 10go_b 11go_a 9go_b 12go_b 13go_b 14go_b 15go_b 16go_b 17go_b 18go_b 19 在上面的例子中，我们让两个协程在每输出一个数字的时候，随机Sleep了一会儿。如果是并行计算，那么输出是无序的。从上面的例子中，我们可以看出两个协程确实并行运行了。 Channel通道Channel提供了协程之间的通信方式以及运行同步机制。 假设训练定点投篮和三分投篮，教练在计数。1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "time")func fixed_shooting(msg_chan chan string) &#123; for &#123; msg_chan &lt;- "fixed shooting" fmt.Println("continue fixed shooting...") &#125;&#125;func count(msg_chan chan string) &#123; for &#123; msg := &lt;-msg_chan fmt.Println(msg) time.Sleep(time.Second * 1) &#125;&#125;func main() &#123; var c chan string c = make(chan string) go fixed_shooting(c) go count(c) var input string fmt.Scanln(&amp;input)&#125; 输出结果为：123456fixed shootingcontinue fixed shooting...fixed shootingcontinue fixed shooting...fixed shootingcontinue fixed shooting... 我们看到在fixed_shooting函数里面我们将消息传递到channel，然后输出提示信息”continue fixed shooting…”，而在count函数里面，我们从channel里面取出消息输出，然后间隔1秒再去取消息输出。这里面我们可以考虑一下，如果我们不去从channel中取消息会出现什么情况？我们把main函数里面的go count(c)注释掉，然后再运行一下。发现程序再也不会输出消息和提示信息了。这是因为channel中根本就没有信息了，因为如果你要向channel里面写信息，必须有配对的取信息的一端，否则是不会写的。 我们再把三分投篮加上。1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "time")func fixed_shooting(msg_chan chan string) &#123; for &#123; msg_chan &lt;- "fixed shooting" &#125;&#125;func three_point_shooting(msg_chan chan string) &#123; for &#123; msg_chan &lt;- "three point shooting" &#125;&#125;func count(msg_chan chan string) &#123; for &#123; msg := &lt;-msg_chan fmt.Println(msg) time.Sleep(time.Second * 1) &#125;&#125;func main() &#123; var c chan string c = make(chan string) go fixed_shooting(c) go three_point_shooting(c) go count(c) var input string fmt.Scanln(&amp;input)&#125; 输出结果为：123456fixed shootingthree point shootingfixed shootingthree point shootingfixed shootingthree point shooting 我们看到程序交替输出定点投篮和三分投篮，这是因为写入channel的信息必须要读取出来，否则尝试再次写入就失败了。 在上面的例子中，我们发现定义一个channel信息变量的方式就是多加一个chan关键字。并且你能够向channel写入数据和从channel读取数据。这里我们还可以设置channel通道的方向。 Channel通道方向所谓的通道方向就是写和读。如果我们如下定义 c chan&lt;- string //那么你只能向channel写入数据 而这种定义 c &lt;-chan string //那么你只能从channel读取数据 试图向只读chan变量写入数据或者试图从只写chan变量读取数据都会导致编译错误。 如果是默认的定义方式 c chan string //那么你既可以向channel写入数据也可以从channnel读取数据 多通道(Select)如果上面的投篮训练现在有两个教练了，各自负责一个训练项目。而且还在不同的篮球场，这个时候很显然，我们一个channel就不够用了。修改一下：12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "time")func fixed_shooting(msg_chan chan string) &#123; for &#123; msg_chan &lt;- "fixed shooting" time.Sleep(time.Second * 1) &#125;&#125;func three_point_shooting(msg_chan chan string) &#123; for &#123; msg_chan &lt;- "three point shooting" time.Sleep(time.Second * 1) &#125;&#125;func main() &#123; c_fixed := make(chan string) c_3_point := make(chan string) go fixed_shooting(c_fixed) go three_point_shooting(c_3_point) go func() &#123; for &#123; select &#123; case msg1 := &lt;-c_fixed: fmt.Println(msg1) case msg2 := &lt;-c_3_point: fmt.Println(msg2) &#125; &#125; &#125;() var input string fmt.Scanln(&amp;input)&#125; 其他的和上面的一样，唯一不同的是我们将定点投篮和三分投篮的消息写入了不同的channel，那么main函数如何知道从哪个channel读取消息呢？使用select方法，select方法依次检查每个channel是否有消息传递过来，如果有就取出来输出。如果同时有多个消息到达，那么select闭上眼睛随机选一个channel来从中读取消息，如果没有一个channel有消息到达，那么select语句就阻塞在这里一直等待。 在某些情况下，比如学生投篮中受伤了，那么就轮到医护人员上场了，教练在一般看看，如果是重伤，教练就不等了，就回去了休息了，待会儿再过来看看情况。我们可以给select加上一个case用来判断是否等待各个消息到达超时。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt" "time")func fixed_shooting(msg_chan chan string) &#123; var times = 3 var t = 1 for &#123; if t &lt;= times &#123; msg_chan &lt;- "fixed shooting" &#125; t++ time.Sleep(time.Second * 1) &#125;&#125;func three_point_shooting(msg_chan chan string) &#123; var times = 5 var t = 1 for &#123; if t &lt;= times &#123; msg_chan &lt;- "three point shooting" &#125; t++ time.Sleep(time.Second * 1) &#125;&#125;func main() &#123; c_fixed := make(chan string) c_3_point := make(chan string) go fixed_shooting(c_fixed) go three_point_shooting(c_3_point) go func() &#123; for &#123; select &#123; case msg1 := &lt;-c_fixed: fmt.Println(msg1) case msg2 := &lt;-c_3_point: fmt.Println(msg2) case &lt;-time.After(time.Second * 5): fmt.Println("timeout, check again...") &#125; &#125; &#125;() var input string fmt.Scanln(&amp;input)&#125; 在上面的例子中，我们让投篮的人在几次过后挂掉，然后教练就每次等5秒出来看看情况（累死丫的，:-P），因为我们对等待的时间不感兴趣就不用变量存储了，直接&lt;-time.After(time.Second*5)，或许你会奇怪，为什么各个channel消息都没有到达，select为什么不阻塞？就是因为这个time.After，虽然它没有显式地告诉你这是一个channel消息，但是记得么？main函数也是一个channel啊！哈哈！至于time.After的功能实际上让main阻塞了5秒后返回给main的channel一个时间。所以我们在case里面把这个时间消息读出来，select就不阻塞了。 输出结果如下：123456789101112fixed shootingthree point shootingfixed shootingthree point shootingfixed shootingthree point shootingthree point shootingthree point shootingtimeout, check again...timeout, check again...timeout, check again...timeout, check again... 这里select还有一个default的选项，如果你指定了default选项，那么当select发现没有消息到达的时候也不会阻塞，直接开始转回去再次判断。 Channel Buffer通道缓冲区我们定义chan变量的时候，还可以指定它的缓冲区大小。一般我们定义的channel都是同步的，也就是说接受端和发送端彼此等待对方ok才开始。但是如果你给一个channel指定了一个缓冲区，那么消息的发送和接受式异步的，除非channel缓冲区已经满了。 c:=make(chan int, 1) 我们看个例子：123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt" "strconv" "time")func shooting(msg_chan chan string) &#123; var group = 1 for &#123; for i := 1; i &lt;= 10; i++ &#123; msg_chan &lt;- strconv.Itoa(group) + ":" + strconv.Itoa(i) &#125; group++ time.Sleep(time.Second * 10) &#125;&#125;func count(msg_chan chan string) &#123; for &#123; fmt.Println(&lt;-msg_chan) &#125;&#125;func main() &#123; var c = make(chan string, 20) go shooting(c) go count(c) var input string fmt.Scanln(&amp;input)&#125; 输出结果为：123456789101112131415161718192021222324252627282930313233343536373839401:11:21:31:41:51:61:71:81:91:102:12:22:32:42:52:62:72:82:92:103:13:23:33:43:53:63:73:83:93:104:14:24:34:44:54:64:74:84:94:10 你可以尝试运行一下，每次都是一下子输出10个数据。然后等待10秒再输出一批。 小结并行计算这种特点最适合用来开发网站服务器，因为一般网站服务都是高并发的，逻辑十分复杂。而使用Go的这种特性恰是提供了一种极好的方法。 使用包和测试管理项目Go天生就是为了支持良好的项目管理体验而设计的。 包在软件工程的实践中，我们会遇到很多功能重复的代码，比如去除字符串首尾的空格。高质量软件产品的特点就是它的部分代码是可以重用的，比如你不必每次写个函数去去除字符串首尾的空格。 我们上面讲过变量，结构体，接口和函数等，事实上所谓的包，就是把一些用的多的这些变量，结构体，接口和函数等统一放置在一个逻辑块中。并且给它们起一个名字，这个名字就叫做包名。 例如我们上面用的最多的fmt包，这个包提供了很多格式化输出的函数，你可以在自己的代码中引用这个包，来做格式化输出，而不用你自己每次去写个函数。一门成熟的语言都会提供齐全的基础功能包供人调用。 使用包有三个好处 可以减少函数名称重复，因为不同包中可以存在名称相同的函数。否则得话，你得给这些函数加上前缀或者后缀以示区别。 包把函数等组织在一起，方便你查找和重用。比如你想用Println()函数输出一行字符串，你可以很方便地知道它在fmt包中，直接引用过来用就可以了。 使用包可以加速程序编译。因为包是预编译好的，你改动自己代码得时候，不必每次去把包编译一下。 创建包我们现在来举个例子，用来演示Go的项目管理。 首先我们在目录/Users/jemy/JemyGraw/GoLang下面创建文件夹pkg_demo。然后在pkg_demo里面创建src文件夹。然后再在main文件夹里面创建main.go文件。另外为了演示包的创建，我们在src目录下面创建文件夹net.duokr，然后再在net.duokr文件夹里面创建math文件夹，这个文件夹名称就是这个文件夹下面go文件的包名称。然后我们再创建一个math_pkg.go文件，之所以取这个名字而不是math.go只是为了说明这个文件名称和包名不需要一致。然后我们还创建了一个math_pkg_test.go文件作为包的测试用例文件。整体结构如下： . └── src ├── main │ ├── build.sh │ └── main.go └── net.duokr └── math ├── math_pkg.go └── math_pkg_test.go 其中build.sh是我们为了编译这个项目而写的脚本，因为编译项目需要几条命令，把它写在脚本文件中方便使用。另外为了能够让build.sh能够执行，使用chmod +x build.sh为它赋予可执行权限。build.bat是Windows下面的编译脚本。我们来看一下math_pkg.go的定义：123456789101112131415161718package mathfunc Add(a, b int) int &#123; return a + b&#125;func Subtract(a, b int) int &#123; return a - b&#125;func Multiply(a, b int) int &#123; return a * b&#125;func Divide(a, b int) int &#123; if b == 0 &#123; panic("Can not divided by zero") &#125; return a / b&#125; 首先是包名，然后是几个函数定义，这里我们会发现这些函数定义首字母都是大写，Go规定了只有首字母大写的函数才能从包导出使用，即其他调用这个包中函数的代码只能调用那些导出的函数。 我们再看一下main.go的定义：12345678910111213141516package mainimport ( "fmt" math "net.duokr/math")func main() &#123; var a = 100 var b = 200 fmt.Println("Add demo:", math.Add(a, b)) fmt.Println("Substract demo:", math.Subtract(a, b)) fmt.Println("Multiply demo:", math.Multiply(a, b)) fmt.Println("Divide demo:", math.Divide(a, b))&#125; 在main.go里面，我们使用import关键字引用我们自定义的包math，引用的方法是从main包平行的文件夹net.duokr开始，后面跟上包名math。这里面我们给这个长长的包名起了一个别名就叫math。然后分别调用math包里面的函数。 最后我们看一下我们的编译脚本：12345export GOPATH=$GOPATH:/Users/jemy/JemyGraw/GoLang/pkg_demoexport GOBIN=/Users/jemy/JemyGraw/GoLang/pkg_demo/bingo build net.duokr/mathgo build main.gogo install main 第一行，我们将项目路径加入GOPATH中，这样待会儿编译main.go的时候才能找到我们自定义的包； 第二行，我们设置本项目的安装目录，第五行的命令将编译好的文件放到这个目录下面； 第三行，我们编译我们的自定义包； 第四行，我们编译我们main.go文件； 第五行，将编译好的文件安装到指定目录下。 这里还有一个Windows下面的编译脚本build.bat：123456@echo offset GOPATH=GOPATH;C:\JemyGraw\GoLang\pkg_demoset GOBIN=C:\JemyGraw\GoLang\pkg_demo\bingo build net.duokr\mathgo build main.gogo install main 好了，运行脚本编译一下，在main文件夹和bin文件夹下面都会生成一个可执行文件。 这个时候文件夹结构为： . ├── bin │ └── main ├── pkg │ └── darwin_386 │ └── net.duokr │ └── math.a └── src ├── main │ ├── build.bat │ ├── build.sh │ ├── main │ └── main.go └── net.duokr └── math ├── math_pkg.go └── math_pkg_test.go 运行一下，输出结果为：1234Add demo: 300Substract demo: -100Multiply demo: 20000Divide demo: 0 好了，包的使用介绍完毕，我们再来看一下测试用例怎么写。 测试在上面的例子中，我们发现我们自定义的包下面还有一个math_pkg_test.go文件，这个文件包含了本包的一些测试用例。而且Go会把以_test.go结尾的文件当作是测试文件。 测试怎么写，当然是用assert来判断程序的运行结果是否和预期的相同了。 我们来看看这个math包的测试用例。123456789101112131415161718192021222324252627282930313233343536373839404142434445package mathimport ( &quot;testing&quot;)func TestAdd(t *testing.T) &#123; var a = 100 var b = 200 var val = Add(a, b) if val != a+b &#123; t.Error(&quot;Test Case [&quot;, &quot;TestAdd&quot;, &quot;] Failed!&quot;) &#125;&#125;func TestSubtract(t *testing.T) &#123; var a = 100 var b = 200 var val = Subtract(a, b) if val != a-b &#123; t.Error(&quot;Test Case [&quot;, &quot;TestSubtract&quot;, &quot;] Failed!&quot;) &#125;&#125;func TestMultiply(t *testing.T) &#123; var a = 100 var b = 200 var val = Multiply(a, b) if val != a*b &#123; t.Error(&quot;Test Case [&quot;, &quot;TestMultiply&quot;, &quot;] Failed!&quot;) &#125;&#125;func TestDivideNormal(t *testing.T) &#123; var a = 100 var b = 200 var val = Divide(a, b) if val != a/b &#123; t.Error(&quot;Test Case [&quot;, &quot;TestDivideNormal&quot;, &quot;] Failed!&quot;) &#125;&#125; 将路径切换到测试文件所在目录，运行go test命令，go会自动测试所有的测试用例。 在上面的例子中，测试用例的特点是以函数名以Test开始，而且具有唯一参数t *testing.T。 小结Go提供的包和用例测试是构建优秀的软件产品的基础，只要我们不断学习，努力去做，一定可以做的很好。]]></content>
      <categories>
        <category>go语言学习笔记</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言基础--函数、指针、结构体、接口]]></title>
    <url>%2F2017%2F07%2F06%2Fgoeasylearn2%2F</url>
    <content type="text"><![CDATA[Go函数是时候讨论一下Go的函数定义了。 什么是函数函数，简单来讲就是一段将输入数据转换为输出数据的公用代码块。当然有的时候函数的返回值为空，那么就是说输出数据为空。而真正的处理过程在函数内部已经完成了。想一想我们为什么需要函数，最直接的需求就是代码中有太多的重复代码了，为了代码的可读性和可维护性，将这些重复代码重构为函数也是必要的。 函数定义先看一个例子1234567891011121314151617181920package mainimport ( "fmt")func slice_sum(arr []int) int &#123; sum := 0 for _, elem := range arr &#123; sum += elem &#125; return sum&#125;func main() &#123; var arr1 = []int&#123;1, 3, 2, 3, 2&#125; var arr2 = []int&#123;3, 2, 3, 1, 6, 4, 8, 9&#125; fmt.Println(slice_sum(arr1)) fmt.Println(slice_sum(arr2))&#125; 在上面的例子中，我们需要分别计算两个切片的元素和。如果我们把计算切片元素的和的代码分别为两个切片展开，那么代码就失去了简洁性和一致性。假设你预想实现同样功能的代码在拷贝粘贴的过程中发生了错误，比如忘记改变量名之类的，到时候debug到崩溃吧。因为这时很有可能你就先入为主了，因为模板代码没有错啊，是不是。所以函数就是这个用处。 我们再仔细看一下上面的函数定义： 首先是关键字func，然后后面是函数名称，参数列表，最后是返回值列表。当然如果函数没有参数列表或者返回值，那么这两项都是可选的。其中返回值两边的括号在只声明一个返回值类型的时候可以省略。 命名返回值Go的函数很有趣，你甚至可以为返回值预先定义一个名称，在函数结束的时候，直接一个return就可以返回所有的预定义返回值。例如上面的例子，我们将sum作为命名返回值。1234567891011121314151617181920package mainimport ( "fmt")func slice_sum(arr []int) (sum int) &#123; sum = 0 for _, elem := range arr &#123; sum += elem &#125; return&#125;func main() &#123; var arr1 = []int&#123;1, 3, 2, 3, 2&#125; var arr2 = []int&#123;3, 2, 3, 1, 6, 4, 8, 9&#125; fmt.Println(slice_sum(arr1)) fmt.Println(slice_sum(arr2))&#125; 这里要注意的是，如果你定义了命名返回值，那么在函数内部你将不能再重复定义一个同样名称的变量。比如第一个例子中我们用sum:=0来定义和初始化变量sum，而在第二个例子中，我们只能用sum=0初始化这个变量了。因为:=表示的是定义并且初始化变量。 实参数和虚参数可能你听说过函数的实参数和虚参数。其实所谓的实参数就是函数调用的时候传入的参数。在上面的例子中，实参就是arr1和arr2，而虚参数就是函数定义的时候表示函数需要传入哪些参数的占位参数。在上面的例子中，虚参就是arr。实参和虚参的名字不必是一样的。即使是一样的，也互不影响。因为虚参是函数的内部变量。而实参则是另一个函数的内部变量或者是全局变量。它们的作用域不同。如果一个函数的虚参碰巧和一个全局变量名称相同，那么函数使用的也是虚参。例如我们再修改一下上面的例子。123456789101112131415161718192021package mainimport ( "fmt")var arr = []int&#123;1, 3, 2, 3, 2&#125;func slice_sum(arr []int) (sum int) &#123; sum = 0 for _, elem := range arr &#123; sum += elem &#125; return&#125;func main() &#123; var arr2 = []int&#123;3, 2, 3, 1, 6, 4, 8, 9&#125; fmt.Println(slice_sum(arr)) fmt.Println(slice_sum(arr2))&#125; 在上面的例子中，我们定义了全局变量arr并且初始化值，而我们的slice_sum函数的虚参也是arr，但是程序同样正常工作。 函数多返回值记不记得你在java或者c里面需要返回多个值时还得去定义一个对象或者结构体的呢？在Go里面，你不需要这么做了。Go函数支持你返回多个值。 其实函数的多返回值，我们在上面遇见过很多次了。那就是range函数。这个函数用来迭代数组或者切片的时候返回的是两个值，一个是数组或切片元素的索引，另外一个是数组或切片元素。在上面的例子中，因为我们不需要元素的索引，所以我们用一个特殊的忽略返回值符号下划线(_)来忽略索引。 假设上面的例子我们除了返回切片的元素和，还想返回切片元素的平均值，那么我们修改一下代码。1234567891011121314151617181920package mainimport ( "fmt")func slice_sum(arr []int) (int, float64) &#123; sum := 0 avg := 0.0 for _, elem := range arr &#123; sum += elem &#125; avg = float64(sum) / float64(len(arr)) return sum, avg&#125;func main() &#123; var arr1 = []int&#123;3, 2, 3, 1, 6, 4, 8, 9&#125; fmt.Println(slice_sum(arr1))&#125; 很简单吧，当然我们还可以将上面的参数定义为命名参数123456789101112131415161718192021package mainimport ( "fmt")func slice_sum(arr []int) (sum int, avg float64) &#123; sum = 0 avg = 0.0 for _, elem := range arr &#123; sum += elem &#125; avg = float64(sum) / float64(len(arr)) //return sum, avg return&#125;func main() &#123; var arr1 = []int&#123;3, 2, 3, 1, 6, 4, 8, 9&#125; fmt.Println(slice_sum(arr1))&#125; 在上面的代码里面，将return sum, avg给注释了而直接使用return。其实这两种返回方式都可以。 变长参数想一想我们的fmt包里面的Println函数，它怎么知道你传入的参数个数呢？1234567891011package mainimport ( "fmt")func main() &#123; fmt.Println(1) fmt.Println(1, 2) fmt.Println(1, 2, 3)&#125; 这个要归功于Go的一大特性，支持可变长参数列表。 首先我们来看一个例子123456789101112131415161718package mainimport ( "fmt")func sum(arr ...int) int &#123; sum := 0 for _, val := range arr &#123; sum += val &#125; return sum&#125;func main() &#123; fmt.Println(sum(1)) fmt.Println(sum(1, 2)) fmt.Println(sum(1, 2, 3))&#125; 在上面的例子中，我们将原来的切片参数修改为可变长参数，然后使用range函数迭代这些参数，并求和。从这里我们可以看出至少一点那就是可变长参数列表里面的参数类型都是相同的（如果你对这句话表示怀疑，可能是因为你看到Println函数恰恰可以输出不同类型的可变参数，这个问题的答案要等到我们介绍完Go的接口后才行）。 另外还有一点需要注意，那就是可变长参数定义只能是函数的最后一个参数。比如下面的例子：123456789101112131415161718package mainimport ( "fmt")func sum(base int, arr ...int) int &#123; sum := base for _, val := range arr &#123; sum += val &#125; return sum&#125;func main() &#123; fmt.Println(sum(100, 1)) fmt.Println(sum(200, 1, 2)) fmt.Println(sum(300, 1, 2, 3))&#125; 这里不知道你是否觉得这个例子其实和那个切片的例子很像啊，在哪里呢？1234567891011121314151617package mainimport ( "fmt")func sum(base int, arr ...int) int &#123; sum := base for _, val := range arr &#123; sum += val &#125; return sum&#125;func main() &#123; var arr1 = []int&#123;1, 2, 3, 4, 5&#125; fmt.Println(sum(300, arr1...))&#125; 呵呵，就是把切片“啪，啪，啪”三个耳光打碎了，传递过去啊！:-P 闭包函数曾经使用python和javascript的时候就在想，如果有一天可以把这两种语言的特性做个并集该有多好。 这一天终于来了，Go支持闭包函数。 首先看一个闭包函数的例子。所谓闭包函数就是将整个函数的定义一气呵成写好并赋值给一个变量。然后用这个变量名作为函数名去调用函数体。 我们将刚刚的例子修改一下：123456789101112131415161718package mainimport ( "fmt")func main() &#123; var arr1 = []int&#123;1, 2, 3, 4, 5&#125; var sum = func(arr ...int) int &#123; total_sum := 0 for _, val := range arr &#123; total_sum += val &#125; return total_sum &#125; fmt.Println(sum(arr1...))&#125; 从这里我们可以看出，其实闭包函数也没有什么特别之处。因为Go不支持在一个函数的内部再定义一个嵌套函数，所以使用闭包函数能够实现在一个函数内部定义另一个函数的目的。 这里我们需要注意的一个问题是，闭包函数对它外层的函数中的变量具有访问和修改的权限。例如：12345678910111213141516171819package mainimport ( "fmt")func main() &#123; var arr1 = []int&#123;1, 2, 3, 4, 5&#125; var base = 300 var sum = func(arr ...int) int &#123; total_sum := 0 total_sum += base for _, val := range arr &#123; total_sum += val &#125; return total_sum &#125; fmt.Println(sum(arr1...))&#125; 这个例子，输出315，因为total_sum加上了base的值。123456789101112131415package mainimport ( "fmt")func main() &#123; var base = 0 inc := func() &#123; base += 1 &#125; fmt.Println(base) inc() fmt.Println(base)&#125; 在上面的例子中，闭包函数修改了main函数的局部变量base。 最后我们来看一个闭包的示例，生成偶数序列。1234567891011121314151617181920package mainimport ( "fmt")func createEvenGenerator() func() uint &#123; i := uint(0) return func() (retVal uint) &#123; retVal = i i += 2 return &#125;&#125;func main() &#123; nextEven := createEvenGenerator() fmt.Println(nextEven()) fmt.Println(nextEven()) fmt.Println(nextEven())&#125; 这个例子很有意思的，因为我们定义了一个返回函数定义的函数。而所返回的函数定义就是在这个函数的内部定义的闭包函数。这个闭包函数在外层函数调用的时候，每次都生成一个新的偶数（加2操作）然后返回闭包函数定义。 其中func() uint就是函数createEvenGenerator的返回值。在createEvenGenerator中，这个返回值是return返回的闭包函数定义。12345func() (retVal uint) &#123; retVal = i i += 2 return&#125; 因为createEvenGenerator函数返回的是一个函数定义，所以我们再把它赋值给一个代表函数的变量，然后用这个代表闭包函数的变量去调用函数执行。 递归函数每次谈到递归函数，必然绕不开阶乘和斐波拉切数列。 阶乘12345678910111213141516171819package main/** n!=1*2*3*...*n*/import ( "fmt")func factorial(x uint) uint &#123; if x == 0 &#123; return 1 &#125; return x * factorial(x-1)&#125;func main() &#123; fmt.Println(factorial(5))&#125; 如果x为0，那么返回1，因为0!=1。如果x是1，那么f(1)=1f(0)，如果x是2，那么f(2)=2f(1)=21f(0)，依次推断f(x)=x(x-1)…21*f(0)。 从上面看出所谓递归，就是在函数的内部重复调用一个函数的过程。需要注意的是这个函数必须能够一层一层分解，并且有出口。上面的例子出口就是0。 斐波拉切数列 求第N个斐波拉切元素1234567891011121314151617181920212223242526package main/** f(1)=1 f(2)=2 f(n)=f(n-2)+f(n-1)*/import ( "fmt")func fibonacci(n int) int &#123; var retVal = 0 if n == 1 &#123; retVal = 1 &#125; else if n == 2 &#123; retVal = 2 &#125; else &#123; retVal = fibonacci(n-2) + fibonacci(n-1) &#125; return retVal&#125;func main() &#123; fmt.Println(fibonacci(5))&#125; 斐波拉切第一个元素是1，第二个元素是2，后面的元素依次是前两个元素的和。 其实对于递归函数来讲，只要知道了函数的出口，后面的不过是让计算机去不断地推断，一直推断到这个出口。理解了这一点，递归就很好理解了。 异常处理当你读取文件失败而退出的时候是否担心文件句柄是否已经关闭？抑或是你对于try…catch…finally的结构中finally里面的代码和try里面的return代码那个先执行这样的问题痛苦不已？ 一切都结束了。一门完美的语言必须有一个清晰的无歧义的执行逻辑。 好，来看看Go提供的异常处理。 defer1234567891011121314151617package mainimport ( "fmt")func first() &#123; fmt.Println("first func run")&#125;func second() &#123; fmt.Println("second func run")&#125;func main() &#123; defer second() first()&#125; Go语言提供了关键字defer来在函数运行结束的时候运行一段代码或调用一个清理函数。上面的例子中，虽然second()函数写在first()函数前面，但是由于使用了defer标注，所以它是在main函数执行结束的时候才调用的。 所以输出结果12first func runsecond func run defer用途最多的在于释放各种资源。比如我们读取一个文件，读完之后需要释放文件句柄。12345678910111213141516171819202122232425package mainimport ( "bufio" "fmt" "os" "strings")func main() &#123; fname := "D:\\Temp\\test.txt" f, err := os.Open(fname) defer f.Close() if err != nil &#123; os.Exit(1) &#125; bReader := bufio.NewReader(f) for &#123; line, ok := bReader.ReadString('\n') if ok != nil &#123; break &#125; fmt.Println(strings.Trim(line, "\r\n")) &#125;&#125; 在上面的例子中，我们按行读取文件，并且输出。从代码中，我们可以看到在使用os包中的Open方法打开文件后，立马跟着一个defer语句用来关闭文件句柄。这样就保证了该文件句柄在main函数运行结束的时候或者异常终止的时候一定能够被释放。而且由于紧跟着Open语句，一旦养成了习惯，就不会忘记去关闭文件句柄了。 panic &amp; recover 当你周末走在林荫道上，听着小歌，哼着小曲，很是惬意。突然之间，从天而降瓢泼大雨，你顿时慌张（panic）起来，没有带伞啊，淋着雨感冒就不好了。于是你四下张望，忽然发现自己离地铁站很近，那里有很多卖伞的，心中顿时又安定了下来（recover），于是你飞奔过去买了一把伞（defer）。 好了，panic和recover是Go语言提供的用以处理异常的关键字。panic用来触发异常，而recover用来终止异常并且返回传递给panic的值。（注意recover并不能处理异常，而且recover只能在defer里面使用，否则无效。） 先瞧个小例子123456789101112package mainimport ( "fmt")func main() &#123; fmt.Println("I am walking and singing...") panic("It starts to rain cats and dogs") msg := recover() fmt.Println(msg)&#125; 看看输出结果 12345runtime.panic(0x48d380, 0xc084003210) C:/Users/ADMINI~1/AppData/Local/Temp/2/bindist667667715/go/src/pkg/runtime/panic.c:266 +0xc8main.main() D:/JemyGraw/Creation/Go/freebook_go/func_d1.go:9 +0xeaexit status 2 咦？怎么没有输出recover获取的错误信息呢？ 这是因为在运行到panic语句的时候，程序已经异常终止了，后面的代码就不运行了。 那么如何才能阻止程序异常终止呢？这个时候要使用defer。因为defer一定是在函数执行结束的时候运行的。不管是正常结束还是异常终止。 修改一下代码1234567891011121314package mainimport ( "fmt")func main() &#123; defer func() &#123; msg := recover() fmt.Println(msg) &#125;() fmt.Println("I am walking and singing...") panic("It starts to rain cats and dogs")&#125; 好了，看下输出12I am walking and singing...It starts to rain cats and dogs 小结： panic触发的异常通常是运行时错误。比如试图访问的索引超出了数组边界，忘记初始化字典或者任何无法轻易恢复到正常执行的错误。 Go指针不要害怕，Go的指针是好指针。 定义所谓指针其实你可以把它想像成一个箭头，这个箭头指向（存储）一个变量的地址。 因为这个箭头本身也需要变量来存储，所以也叫做指针变量。 Go的指针不支持那些乱七八糟的指针移位。它就表示一个变量的地址。看看这个例子：1234567891011121314151617package mainimport ( "fmt")func main() &#123; var x int var x_ptr *int x = 10 x_ptr = &amp;x fmt.Println(x) fmt.Println(x_ptr) fmt.Println(*x_ptr)&#125; 上面例子输出x的值，x的地址和通过指针变量输出x的值，而x_ptr就是一个指针变量。123100xc08400003810 认真理清楚这两个符号的意思。 &amp; 取一个变量的地址 * 取一个指针变量所指向的地址的值 考你一下，上面的例子中，如何输出x_ptr的地址呢？123456789101112131415package mainimport ( "fmt")func main() &#123; var x int var x_ptr *int x = 10 x_ptr = &amp;x fmt.Println(&amp;x_ptr)&#125; 此例看懂，指针就懂了。 永远记住一句话，所谓指针就是一个指向（存储）特定变量地址的变量。没有其他的特别之处。 再变态一下，看看这个：123456789101112131415package mainimport ( &quot;fmt&quot;)func main() &#123; var x int var x_ptr *int x = 10 x_ptr = &amp;x fmt.Println(*&amp;x_ptr)&#125; x_ptr 是一个指针变量，它指向(存储)x的地址； &amp;x_ptr 是取这个指针变量x_ptr的地址，这里可以设想有另一个指针变量x_ptr_ptr(指向)存储这个x_ptr指针的地址； &amp;x_ptr 等价于`x_ptr_ptr就是取这个x_ptr_ptr指针变量所指向(存储)的地址所对应的变量的值，也就是x_ptr的值，也就是指针变量x_ptr指向(存储)的地址，也就是x的地址。 这里可以看到，其实*&amp;`这两个运算符在一起就相互抵消作用了。 用途指针的一大用途就是可以将变量的指针作为实参传递给函数，从而在函数内部能够直接修改实参所指向的变量值。 Go的变量传递都是值传递。123456789101112131415package mainimport ( "fmt")func change(x int) &#123; x = 200&#125;func main() &#123; var x int = 100 fmt.Println(x) change(x) fmt.Println(x)&#125; 上面的例子输出结果为12100100 很显然，change函数改变的仅仅是内部变量x的值，而不会改变传递进去的实参。其实，也就是说Go的函数一般关心的是输出结果，而输入参数就相当于信使跑到函数门口大叫，你们这个参数是什么值，那个是什么值，然后就跑了。你函数根本就不能修改它的值。不过如果是传递的实参是指针变量，那么函数一看，小子这次你地址我都知道了，哪里跑。那么就是下面的例子：123456789101112131415package mainimport ( "fmt")func change(x *int) &#123; *x = 200&#125;func main() &#123; var x int = 100 fmt.Println(x) change(&amp;x) fmt.Println(x)&#125; 上面的例子中，change函数的虚参为整型指针变量，所以在main中调用的时候传递的是x的地址。然后在change里面使用*x=200修改了这个x的地址的值。所以x的值就变了。这个输出是：12100200 newnew这个函数挺神奇，因为它的用处太多了。这里还可以通过new来初始化一个指针。上面说过指针指向(存储)的是一个变量的地址，但是指针本身也需要地址存储。先看个例子：12345678910111213141516171819package mainimport ( "fmt")func set_value(x_ptr *int) &#123; *x_ptr = 100&#125;func main() &#123; x_ptr := new(int) set_value(x_ptr) //x_ptr指向的地址 fmt.Println(x_ptr) //x_ptr本身的地址 fmt.Println(&amp;x_ptr) //x_ptr指向的地址值 fmt.Println(*x_ptr)&#125; 上面我们定义了一个x_ptr变量，然后用new申请了一个存储整型数据的内存地址，然后将这个地址赋值给x_ptr指针变量，也就是说x_ptr指向（存储）的是一个可以存储整型数据的地址，然后用set_value函数将这个地址中存储的值赋值为100。所以第一个输出是x_ptr指向的地址，第二个则是x_ptr本身的地址，而*x_ptr则是x_ptr指向的地址中存储的整型数据的值。 1230xc0840000400xc084000038100 小结好了，现在用个例子再来回顾一下指针。 交换两个变量的值。12345678910111213141516package mainimport ( "fmt")func swap(x, y *int) &#123; *x, *y = *y, *x&#125;func main() &#123; x_val := 100 y_val := 200 swap(&amp;x_val, &amp;y_val) fmt.Println(x_val) fmt.Println(y_val)&#125; 很简单吧，这里利用了Go提供的交叉赋值的功能，另外由于是使用了指针作为参数，所以在swap函数内，x_val和y_val的值就被交换了。 Go结构体和指针基本上到这里的时候，就是上了一个台阶了。Go的精华特点即将展开。 结构体定义上面我们说过Go的指针和C的不同，结构体也是一样的。Go是一门删繁就简的语言，一切令人困惑的特性都必须去掉。 简单来讲，Go提供的结构体就是把使用各种数据类型定义的不同变量组合起来的高级数据类型。闲话不多说，看例子:1234type Rect struct &#123; width float64 length float64&#125; 上面我们定义了一个矩形结构体，首先是关键是type表示要定义一个新的数据类型了，然后是新的数据类型名称Rect，最后是struct关键字，表示这个高级数据类型是结构体类型。在上面的例子中，因为width和length的数据类型相同，还可以写成如下格式： 123type Rect struct &#123; width, length float64&#125; 好了，来用结构体干点啥吧，计算一下矩形面积。12345678910111213141516package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func main() &#123; var rect Rect rect.width = 100 rect.length = 200 fmt.Println(rect.width * rect.length)&#125; 从上面的例子看到，其实结构体类型和基础数据类型使用方式差不多，唯一的区别就是结构体类型可以通过.来访问内部的成员。包括给内部成员赋值和读取内部成员值。 在上面的例子中，我们是用var关键字先定义了一个Rect变量，然后对它的成员赋值。我们也可以使用初始化的方式来给Rect变量的内部成员赋值。123456789101112131415package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func main() &#123; var rect = Rect&#123;width: 100, length: 200&#125; fmt.Println(rect.width * rect.length)&#125; 当然如果你知道结构体成员定义的顺序，也可以不使用key:value的方式赋值，直接按照结构体成员定义的顺序给它们赋值。12345678910111213141516package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println("Width:", rect.width, "* Length:", rect.length, "= Area:", rect.width*rect.length)&#125; 输出结果为 Width: 100 * Length: 200 = Area: 20000 结构体参数传递方式我们说过，Go函数的参数传递方式是值传递，这句话对结构体也是适用的。 1234567891011121314151617181920package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func double_area(rect Rect) float64 &#123; rect.width *= 2 rect.length *= 2 return rect.width * rect.length&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println(double_area(rect)) fmt.Println("Width:", rect.width, "Length:", rect.length)&#125; 上面的例子输出为:1280000Width: 100 Length: 200 也就说虽然在double_area函数里面我们将结构体的宽度和长度都加倍，但仍然没有影响main函数里面的rect变量的宽度和长度。 结构体组合函数上面我们在main函数中计算了矩形的面积，但是我们觉得矩形的面积如果能够作为矩形结构体的“内部函数”提供会更好。这样我们就可以直接说这个矩形面积是多少，而不用另外去取宽度和长度去计算。现在我们看看结构体“内部函数”定义方法： 1234567891011121314151617181920package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func (rect Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = Rect&#123;100, 200&#125; fmt.Println("Width:", rect.width, "Length:", rect.length, "Area:", rect.area())&#125; 咦？这个是什么“内部方法”，根本没有定义在Rect数据类型的内部啊？ 确实如此，我们看到，虽然main函数中的rect变量可以直接调用函数area()来获取矩形面积，但是area()函数确实没有定义在Rect结构体内部，这点和C语言的有很大不同。Go使用组合函数的方式来为结构体定义结构体方法。我们仔细看一下上面的area()函数定义。 首先是关键字func表示这是一个函数，第二个参数是结构体类型和实例变量，第三个是函数名称，第四个是函数返回值。这里我们可以看出area()函数和普通函数定义的区别就在于area()函数多了一个结构体类型限定。这样一来Go就知道了这是一个为结构体定义的方法。 这里需要注意一点就是定义在结构体上面的函数(function)一般叫做方法(method)。 结构体和指针我们在指针一节讲到过，指针的主要作用就是在函数内部改变传递进来变量的值。对于上面的计算矩形面积的例子，我们可以修改一下代码如下：123456789101112131415161718192021package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func (rect *Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println("Width:", rect.width, "Length:", rect.length, "Area:", rect.area())&#125; 上面的例子中，使用了new函数来创建一个结构体指针rect，也就是说rect的类型是*Rect，结构体遇到指针的时候，你不需要使用*去访问结构体的成员，直接使用.引用就可以了。所以上面的例子中我们直接使用rect.width=100 和rect.length=200来设置结构体成员值。因为这个时候rect是结构体指针，所以我们定义area()函数的时候结构体限定类型为*Rect。 其实在计算面积的这个例子中，我们不需要改变矩形的宽或者长度，所以定义area函数的时候结构体限定类型仍然为Rect也是可以的。如下：123456789101112131415161718192021package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func (rect Rect) area() float64 &#123; return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println("Width:", rect.width, "Length:", rect.length, "Area:", rect.area())&#125; 这里Go足够聪明，所以rect.area()也是可以的。 至于使不使用结构体指针和使不使用指针的出发点是一样的，那就是你是否试图在函数内部改变传递进来的参数的值。再举个例子如下：12345678910111213141516171819202122232425package mainimport ( "fmt")type Rect struct &#123; width, length float64&#125;func (rect *Rect) double_area() float64 &#123; rect.width *= 2 rect.length *= 2 return rect.width * rect.length&#125;func main() &#123; var rect = new(Rect) rect.width = 100 rect.length = 200 fmt.Println(*rect) fmt.Println("Double Width:", rect.width, "Double Length:", rect.length, "Double Area:", rect.double_area()) fmt.Println(*rect)&#125; 这个例子的输出是：123&#123;100 200&#125;Double Width: 200 Double Length: 400 Double Area: 80000&#123;200 400&#125; 结构体内嵌类型我们可以在一个结构体内部定义另外一个结构体类型的成员。例如iPhone也是Phone，我们看下例子：1234567891011121314151617181920212223242526package mainimport ( "fmt")type Phone struct &#123; price int color string&#125;type IPhone struct &#123; phone Phone model string&#125;func main() &#123; var p IPhone p.phone.price = 5000 p.phone.color = "Black" p.model = "iPhone 5" fmt.Println("I have a iPhone:") fmt.Println("Price:", p.phone.price) fmt.Println("Color:", p.phone.color) fmt.Println("Model:", p.model)&#125; 输出结果为1234I have a iPhone:Price: 5000Color: BlackModel: iPhone 5 在上面的例子中，我们在结构体IPhone里面定义了一个Phone变量phone，然后我们可以像正常的访问结构体成员一样访问phone的成员数据。但是我们原来的意思是“iPhone也是(is-a)Phone”，而这里的结构体IPhone里面定义了一个phone变量，给人的感觉就是“iPhone有一个(has-a)Phone”，挺奇怪的。当然Go也知道这种方式很奇怪，所以支持如下做法： 1234567891011121314151617181920212223242526package mainimport ( "fmt")type Phone struct &#123; price int color string&#125;type IPhone struct &#123; Phone model string&#125;func main() &#123; var p IPhone p.price = 5000 p.color = "Black" p.model = "iPhone 5" fmt.Println("I have a iPhone:") fmt.Println("Price:", p.price) fmt.Println("Color:", p.color) fmt.Println("Model:", p.model)&#125; 输出结果为1234I have a iPhone:Price: 5000Color: BlackModel: iPhone 5 在这个例子中，我们定义IPhone结构体的时候，不再定义Phone变量，直接把结构体Phone类型定义在那里。然后IPhone就可以像访问直接定义在自己结构体里面的成员一样访问Phone的成员。 上面的例子中，我们演示了结构体的内嵌类型以及内嵌类型的成员访问，除此之外，假设结构体A内部定义了一个内嵌结构体B，那么A同时也可以调用所有定义在B上面的函数。 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt")type Phone struct &#123; price int color string&#125;func (phone Phone) ringing() &#123; fmt.Println("Phone is ringing...")&#125;type IPhone struct &#123; Phone model string&#125;func main() &#123; var p IPhone p.price = 5000 p.color = "Black" p.model = "iPhone 5" fmt.Println("I have a iPhone:") fmt.Println("Price:", p.price) fmt.Println("Color:", p.color) fmt.Println("Model:", p.model) p.ringing()&#125; 输出结果为：12345I have a iPhone:Price: 5000Color: BlackModel: iPhone 5Phone is ringing... 接口我们先看一个例子，关于Nokia手机和iPhone手机都能够打电话的例子。1234567891011121314151617181920212223242526package mainimport ( "fmt")type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println("I am Nokia, I can call you!")&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println("I am iPhone, I can call you!")&#125;func main() &#123; var nokia NokiaPhone nokia.call() var iPhone IPhone iPhone.call()&#125; 我们定义了NokiaPhone和IPhone，它们都有各自的方法call()，表示自己都能够打电话。但是我们想一想，是手机都应该能够打电话，所以这个不算是NokiaPhone或是IPhone的独特特点。否则iPhone不可能卖这么贵了。 再仔细看一下接口的定义，首先是关键字type，然后是接口名称，最后是关键字interface表示这个类型是接口类型。在接口类型里面，我们定义了一组方法。 Go语言提供了一种接口功能，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口，不一定非要显式地声明要去实现哪些接口啦。比如上面的手机的call()方法，就完全可以定义在接口Phone里面，而NokiaPhone和IPhone只要实现了这个接口就是一个Phone。12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt")type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println("I am Nokia, I can call you!")&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println("I am iPhone, I can call you!")&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 在上面的例子中，我们定义了一个接口Phone，接口里面有一个方法call()，仅此而已。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法，输出结果如下：12I am Nokia, I can call you!I am iPhone, I can call you! 以前我们说过，Go语言式静态类型语言，变量的类型在运行过程中不能改变。但是在上面的例子中，phone变量好像先定义为Phone类型，然后是NokiaPhone类型，最后成为了IPhone类型，真的是这样吗？ 原来，在Go语言里面，一个类型A只要实现了接口X所定义的全部方法，那么A类型的变量也是X类型的变量。在上面的例子中，NokiaPhone和IPhone都实现了Phone接口的call()方法，所以它们都是Phone，这样一来是不是感觉正常了一些。 我们为Phone添加一个方法sales()，再来熟悉一下接口用法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "fmt")type Phone interface &#123; call() sales() int&#125;type NokiaPhone struct &#123; price int&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println("I am Nokia, I can call you!")&#125;func (nokiaPhone NokiaPhone) sales() int &#123; return nokiaPhone.price&#125;type IPhone struct &#123; price int&#125;func (iPhone IPhone) call() &#123; fmt.Println("I am iPhone, I can call you!")&#125;func (iPhone IPhone) sales() int &#123; return iPhone.price&#125;func main() &#123; var phones = [5]Phone&#123; NokiaPhone&#123;price: 350&#125;, IPhone&#123;price: 5000&#125;, IPhone&#123;price: 3400&#125;, NokiaPhone&#123;price: 450&#125;, IPhone&#123;price: 5000&#125;, &#125; var totalSales = 0 for _, phone := range phones &#123; totalSales += phone.sales() &#125; fmt.Println(totalSales)&#125; 输出结果： 14200 上面的例子中，我们定义了一个手机数组，然后计算手机的总售价。可以看到，由于NokiaPhone和IPhone都实现了sales()方法，所以它们都是Phone类型，但是计算售价的时候，Go会知道调用哪个对象实现的方法。 接口类型还可以作为结构体的数据成员。 假设有个败家子，iPhone没有出的时候，买了好几款Nokia，iPhone出来后，又买了好多部iPhone，老爸要来看看这小子一共花了多少钱。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt")type Phone interface &#123; sales() int&#125;type NokiaPhone struct &#123; price int&#125;func (nokiaPhone NokiaPhone) sales() int &#123; return nokiaPhone.price&#125;type IPhone struct &#123; price int&#125;func (iPhone IPhone) sales() int &#123; return iPhone.price&#125;type Person struct &#123; phones []Phone name string age int&#125;func (person Person) total_cost() int &#123; var sum = 0 for _, phone := range person.phones &#123; sum += phone.sales() &#125; return sum&#125;func main() &#123; var bought_phones = [5]Phone&#123; NokiaPhone&#123;price: 350&#125;, IPhone&#123;price: 5000&#125;, IPhone&#123;price: 3400&#125;, NokiaPhone&#123;price: 450&#125;, IPhone&#123;price: 5000&#125;, &#125; var person = Person&#123;name: "Jemy", age: 25, phones: bought_phones[:]&#125; fmt.Println(person.name) fmt.Println(person.age) fmt.Println(person.total_cost())&#125; 这个例子纯为演示接口作为结构体数据成员，如有雷同，纯属巧合。这里面我们定义了一个Person结构体，结构体内部定义了一个手机类型切片。另外我们定义了Person的total_cost()方法用来计算手机花费总额。输出结果如下：123Jemy2514200 小结Go的结构体和接口的实现方法可谓删繁就简，去除了很多别的语言令人困惑的地方，而且学习难度也不大，很容易上手。不过由于思想比较独到，也有可能会有人觉得功能太简单而无用，这个就各有看法了，不过在逐渐的使用过程中，我们会慢慢领悟到这种设计所带来的好处，以及所避免的问题。]]></content>
      <categories>
        <category>go语言学习笔记</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言基础--数据类型、变量、控制]]></title>
    <url>%2F2017%2F07%2F06%2Fgoeasylearn1%2F</url>
    <content type="text"><![CDATA[Go语言内置基础数据类型在自然界里面，有猫，有狗，有猪。有各种动物。每种动物都是不同的。比如猫会喵喵叫，狗会旺旺叫，猪会哼哼叫。。。Stop!!!好了，大家毕竟不是幼儿园的小朋友。介绍到这里就可以了。论点就是每个东西都有自己归属的类别(Type)。那么在Go语言里面，每个变量也都是有类别的，这种类别叫做数据类型(Data Type)。Go的数据类型有两种：一种是语言内置的数据类型，另外一种是通过语言提供的自定义数据类型方法自己定义的自定义数据类型。 先看看语言内置的基础数据类型 数值型(Number)数值型有三种，一种是整数类型，另外一种是带小数的类型(一般计算机里面叫做浮点数类型)，还有一种虚数类型。 整数类型不用说了，和数学里面的是一样的。和数学里面不同的地方在于计算机里面正整数和零统称为无符号整型，而负整数则称为有符号整型。 Go的内置整型有uint8, uint16, uint32, uint64, int8, int16, int32和int64。其中u开头的类型就是无符号整型。无符号类型能够表示正整数和零。而有符号类型除了能够表示正整数和零外，还可以表示负整数。另外还有一些别名类型，比如byte类型，这个类型和uint8是一样的，表示字节类型。另外一个是rune类型，这个类型和int32是一样的，用来表示unicode的代码点，就是unicode字符所对应的整数。 Go还定义了三个依赖系统的类型，uint，int和uintptr。因为在32位系统和64位系统上用来表示这些类型的位数是不一样的。 对于32位系统 uint=uint32int=int32uintptr为32位的指针 对于64位系统 uint=uint64int=int64uintptr为64位的指针 至于类型后面跟的数字8，16，32或是64则表示用来表示这个类型的位不同，位越多，能表示的整数范围越大。比如对于用N位来表示的整数，如果是有符号的整数，能够表示的整数范围为-2^(N-1) ~ 2^(N-1)－1；如果是无符号的整数，则能表示的整数范围为0 ～ 2^N。 Go的浮点数类型有两种，float32和float64。float32又叫单精度浮点型，float64又叫做双精度浮点型。其最主要的区别就是小数点后面能跟的小数位数不同。 另外Go还有两个其他语言所没有的类型，虚数类型。complex64和complex128。 对于数值类型，其所共有的操作为加法(＋)，减法(－)，乘法(＊)和除法(/)。另外对于整数类型，还定义了求余运算(%) 求余运算为整型所独有。如果对浮点数使用求余，比如这样123456789101112package mainimport ( "fmt")func main() &#123; var a float64 = 12 var b float64 = 3 fmt.Println(a % b)&#125; 编译时候会报错 invalid operation: a % b (operator % not defined on float64) 所以，这里我们可以知道所谓的数据类型有两层意思，一个是定义了该类型所能表示的数，另一个是定义了该类型所能进行的操作。简单地说，对于一只小狗，你能想到的一定是狗的面貌和它会汪汪叫，而不是猫的面容和喵喵叫。 字符串类型(String)字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。（对于汉字，通常由多个字节组成）。这就是说，传统的字符串是由字符组成的，而Go的字符串不同，是由字节组成的。这一点需要注意。 字符串的表示很简单。用(双引号””)或者(号)来描述。 &quot;hello world&quot; 或者 `hello world` 唯一的区别是，双引号之间的转义字符会被转义，而号之间的转义字符保持原样不变。1234567891011121314package mainimport ( "fmt")func main() &#123; var a = "hello \n world" var b = `hello \n world` fmt.Println(a) fmt.Println("----------") fmt.Println(b)&#125; 输出结果为1234hello world----------hello \n world 字符串所能进行的一些基本操作包括:（1）获取字符长度（2）获取字符串中单个字节（3）字符串连接1234567891011121314package mainimport ( "fmt")func main() &#123; var a string = "hello" var b string = "world" fmt.Println(len(a)) fmt.Println(a[1]) fmt.Println(a + b)&#125; 输出如下1235101helloworld 这里我们看到a[1]得到的是一个整数，这就证明了上面&quot;Go的字符串是由字节组成的这句话&quot;。我们还可以再验证一下。12345678910111213141516package mainimport ( "fmt")func main() &#123; var a string = "你" var b string = "好" fmt.Println(len(a)) fmt.Println(len(b)) fmt.Println(len(a + b)) fmt.Println(a[0]) fmt.Println(a[1]) fmt.Println(a[2])&#125; 输出123456336228189160 我们开始的时候，从上面的三行输出知道，”你”和”好”分别是用三个字节组成的。我们依次获取a的三个字节，输出，得到结果。 布尔型(Bool)布尔型是表示真值和假值的类型。可选值为true和false。 所能进行的操作如下：&amp;&amp; and 与|| or 或! not 非 Go的布尔型取值就是true或false。任何空值(nil)或者零值(0, 0.0, &quot;&quot;)都不能作为布尔型来直接判断。12345678910111213package mainimport ( "fmt")func main() &#123; var equal bool var a int = 10 var b int = 20 equal = (a == b) fmt.Println(equal)&#125; 输出结果 false 下面是错误的用法1234567891011121314151617package mainimport ( "fmt")func main() &#123; if 0 &#123; fmt.Println("hello world") &#125; if nil &#123; fmt.Println("hello world") &#125; if "" &#123; fmt.Println("hello world") &#125;&#125; 编译错误123./t.go:8: non-bool 0 (type untyped number) used as if condition./t.go:11: non-bool nil used as if condition./t.go:14: non-bool &quot;&quot; (type untyped string) used as if condition 上面介绍的是Go语言内置的基础数据类型。 变量和常量定义现在我们讨论一下Go语言的变量定义。 变量定义所谓的变量就是一个拥有指定名称和类型的数据存储位置。在上面我们使用过变量的定义，现在我们来仔细看一个例子。 12345678910package mainimport ( "fmt")func main() &#123; var x string = "hello world" fmt.Println(x)&#125; 变量的定义首先使用var关键字，然后指定变量的名称x，再指定变量的类型string，在本例中，还对变量x进行了赋值，然后在命令行输出该变量。Go这种变量定义的方式和其他的语言有些不同，但是在使用的过程中，你会逐渐喜欢的。当然上面的变量定义方式还可以如下，即先定义变量，再赋值。1234567891011package mainimport ( "fmt")func main() &#123; var x string x = "hello world" fmt.Println(x)&#125; 或者是直接赋值，让Go语言推断变量的类型。如下：12345678910package mainimport ( "fmt")func main() &#123; var x = "hello world" fmt.Println(x)&#125; 当然，上面变量的定义还有一种快捷方式。如果你知道变量的初始值，完全可以像下面这样定义变量，完全让Go来推断语言的类型。这种定义的方式连关键字var都省略掉了。12345678910package mainimport ( "fmt")func main() &#123; x := "hello world" fmt.Println(x)&#125; 注意：上面这种使用:=方式定义变量的方式只能用在函数内部。123456789101112package mainimport ( "fmt")x:="hello world"func main() &#123; y := 10 fmt.Println(x) fmt.Println(y)&#125; 对于上面的变量定义x是无效的。会导致编译错误： ./test_var_quick.go:7: non-declaration statement outside function body 不过我们对上面的例子做下修改，比如这样是可以的。也就是使用var关键字定义的时候，如果给出初始值，就不需要显式指定变量类型。12345678910111213package mainimport ( "fmt")var x = "hello world"func main() &#123; y := 10 fmt.Println(x) fmt.Println(y)&#125; 变量之所以称为变量，就是因为它们的值在程序运行过程中可以发生变化，但是它们的变量类型是无法改变的。因为Go语言是静态语言，并不支持程序运行过程中变量类型发生变化。比如如果你强行将一个字符串值赋值给定义为int的变量，那么会发生编译错误。即使是强制类型转换也是不可以的。强制类型转换只支持同类的变量类型。比如数值类型之间强制转换。 下面我们看几个例子：123456789101112package mainimport ( "fmt")func main() &#123; var x string = "hello world" fmt.Println(x) x = "i love go language" fmt.Println(x)&#125; 本例子演示变量的值在程序运行过程中发生变化，结果输出为12hello worldi love go language 我们尝试不同类型的变量之间转换123456789101112package mainimport ( "fmt")func main() &#123; var x string = "hello world" fmt.Println(x) x = 11 fmt.Println(x)&#125; 在本例子中，如果试图将一个数值赋予字符串变量x，那么会发生错误： ./test_var.go:10: cannot use 11 (type int) as type string in assignment 上面的意思就是无法将整型数值11当作字符串赋予给字符串变量。 但是同类的变量之间是可以强制转换的，如浮点型和整型之间的转换。1234567891011package mainimport ( "fmt")func main() &#123; var x float64 = 32.35 fmt.Println(x) fmt.Println(int(x))&#125; 输出的结果为1232.35 32 变量命名上面我们看了一些变量的使用方法，那么定义一个变量名称，有哪些要求呢？这里我们要注意，Go的变量名称必须以字母或下划线(_)开头，后面可以跟字母，数字，或者下划线(_)。除此之外，Go语言并不关心你如何定义变量。我们通用的做法是定义一个用户友好的变量。假设你需要定义一个狗狗的年龄，那么使用dog_age作为变量名称要好于用x来定义变量。 变量作用域现在我们再来讨论一下变量的作用域。所谓作用域就是可以有效访问变量的区域。比如很简单的，你不可能在一个函数func_a里面访问另一个函数func_b里面定义的局部变量x。所以变量的作用域目前分为两类，一个是全局变量，另一个是局部变量。下面我们看个全局变量的例子：1234567891011package mainimport ( "fmt")var x string = "hello world"func main() &#123; fmt.Println(x)&#125; 这里变量x定义在main函数之外，但是main函数仍然可以访问x。全局变量的作用域是该包中所有的函数。12345678910111213141516package mainimport ( "fmt")var x string = "hello world"func change() &#123; x = "i love go"&#125;func main() &#123; fmt.Println(x) change() fmt.Println(x)&#125; 在上面的例子用，我们用了change函数改变了x的值。输出结果如下：12hello worldi love go 我们再看一下局部变量的例子。123456789101112package mainimport ( "fmt")func change() &#123; x := "i love go"&#125;func main() &#123; fmt.Println(x)&#125; 该例子中main函数试图访问change函数中定义的局部变量x，结果发生了下面的错误(未定义的变量x)： ./test_var.go:11: undefined: x 常量Go语言也支持常量定义。所谓常量就是在程序运行过程中保持值不变的变量定义。常量的定义和变量类似，只是用const关键字替换了var关键字，另外常量在定义的时候必须有初始值。123456789101112package mainimport ( "fmt")func main() &#123; const x string = "hello world" const y = "hello world" fmt.Println(x) fmt.Println(y)&#125; 这里有一点需要注意，变量定义的类型推断方式:=不能够用来定义常量。因为常量的值是在编译的时候就已经确定的，但是变量的值则是运行的时候才使用的。这样常量定义就无法使用变量类型推断的方式了。 常量的值在运行过程中是无法改变的，强制改变常量的值是无效的。 123456789101112package mainimport ( "fmt")func main() &#123; const x string = "hello world" fmt.Println(x) x = "i love go language" fmt.Println(x)&#125; 比如上面的例子就会报错 ./test_var.go:10: cannot assign to x 我们再看一个Go包math里面定义的常量Pi，用它来求圆的面积。123456789101112package mainimport ( "fmt" "math")func main() &#123; var radius float64 = 10 var area = math.Pow(radius, 2) * math.Pi fmt.Println(area)&#125; 多变量或常量定义Go还提供了一种同时定义多个变量或者常量的快捷方式。1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var ( a int = 10 b float64 = 32.45 c bool = true ) const ( Pi float64 = 3.14 True bool = true ) fmt.Println(a, b, c) fmt.Println(Pi, True)&#125; 程序控制结构虽然剧透可耻，但是为了体现Go语言的设计简洁之处，必须要先剧透一下。 Go语言的控制结构关键字只有 if..else if..else，for 和 switch。 而且在Go中，为了避免格式化战争，对程序结构做了统一的强制的规定。看下下面的例子。 请比较一下A程序和B程序的不同之处。 A程序123456789package mainimport ( "fmt")func main() &#123; fmt.Println("hello world")&#125; B程序12345678910package mainimport ( "fmt")func main() &#123; fmt.Println("hello world")&#125; 还记得我们前面的例子中，{}的格式是怎么样的么？在上面的两个例子中只有A例的写法是对的。因为在Go语言中，强制了{}的格式。如果我们试图去编译B程序，那么会发生如下的错误提示。 ./test_format.go:9: syntax error: unexpected semicolon or newline before { if..else if..elseif..else if..else 用来判断一个或者多个条件，然后根据条件的结果执行不同的程序块。举个简单的例子。1234567891011121314151617package mainimport ( "fmt")func main() &#123; var dog_age = 10 if dog_age &gt; 10 &#123; fmt.Println("A big dog") &#125; else if dog_age &gt; 1 &amp;&amp; dog_age &lt;= 10 &#123; fmt.Println("A small dog") &#125; else &#123; fmt.Println("A baby dog") &#125;&#125; 上面的例子判断狗狗的年龄如果(if)大于10就是一个大狗；否则判断(else if)狗狗的年龄是否小于等于10且大于1，这个时候狗狗是小狗狗。否则(else)的话（就是默认狗狗的年龄小于等于1岁），那么狗狗是Baby狗狗。 在上面的例子中，我们还可以发现Go的if..else if..else语句的判断条件一般都不需要使用()。当然如果你还是愿意写，也是对的。另外如果为了将某两个或多个条件绑定在一起判断的话，还是需要括号()的。 比如下面的例子也是对的。1234567891011121314151617package mainimport ( "fmt")func main() &#123; const Male = 'M' const Female = 'F' var dog_age = 10 var dog_sex = 'M' if (dog_age == 10 &amp;&amp; dog_sex == 'M') &#123; fmt.Println("dog") &#125;&#125; 但是如果你使用Go提供的格式化工具来格式化这段代码的话，Go会智能判断你的括号是否必须有，否则的话，会帮你去掉的。你可以试试。 go fmt test_bracket.go 然后你会发现，咦？！果真被去掉了。 另外因为每个判断条件的结果要么是true要么是false，所以可以使用&amp;&amp;，||来连接不同的条件。使用!来对一个条件取反。 switchswitch的出现是为了解决某些情况下使用if判断语句带来的繁琐之处。 例如下面的例子：12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; //score 为 [0,100]之间的整数 var score int = 69 if score &gt;= 90 &amp;&amp; score &lt;= 100 &#123; fmt.Println("优秀") &#125; else if score &gt;= 80 &amp;&amp; score &lt; 90 &#123; fmt.Println("良好") &#125; else if score &gt;= 70 &amp;&amp; score &lt; 80 &#123; fmt.Println("一般") &#125; else if score &gt;= 60 &amp;&amp; score &lt; 70 &#123; fmt.Println("及格") &#125; else &#123; fmt.Println("不及格") &#125;&#125; 在上面的例子中，我们用if..else if..else来对分数进行分类。这个只是一般的情况下if判断条件的数量。如果if..else if..else的条件太多的话，我们可以使用switch来优化程序。比如上面的程序我们还可以这样写：123456789101112131415161718192021222324package mainimport ( "fmt")func main() &#123; //score 为 [0,100]之间的整数 var score int = 69 switch score / 10 &#123; case 10: case 9: fmt.Println("优秀") case 8: fmt.Println("良好") case 7: fmt.Println("一般") case 6: fmt.Println("及格") default: fmt.Println("不及格") &#125;&#125; 关于switch的几点说明如下： (1) switch的判断条件可以为任何数据类型。123456789101112131415package mainimport ( "fmt")func main() &#123; var dog_sex = "F" switch dog_sex &#123; case "M": fmt.Println("A male dog") case "F": fmt.Println("A female dog") &#125;&#125; (2) 每个case后面跟的是一个完整的程序块，该程序块不需要{}，也不需要break结尾，因为每个case都是独立的。 (3) 可以为switch提供一个默认选项default，在上面所有的case都没有满足的情况下，默认执行default后面的语句。 forfor用在Go语言的循环条件里面。比如说要你输出1…100之间的自然数。最笨的方法就是直接这样。123456789101112package mainimport ( "fmt")func main() &#123; fmt.Println(1) fmt.Println(2) ... fmt.Println(100)&#125; 这个不由地让我想起一个笑话。 以前一个地主的儿子学习写字，只学了三天就把老师赶走了。因为在这三天里面他学写了一，二，三。他觉得写字真的太简单了，不就是画横线嘛。于是有一天老爹过寿，让他来记送礼的人名单。直到中午还没有记完，老爹很奇怪就去问他怎么了。他哭着说，“不知道这个人有什么毛病，姓什么不好，姓万”。 哈哈，回来继续。我们看到上面的例子也是如地主的儿子那样就不好了。所以，我们必须使用循环结构。我们用for的循环语句来实现上面的例子。12345678910111213package mainimport ( "fmt")func main() &#123; var i int = 1 for ; i &lt;= 100; i++ &#123; fmt.Println(i) &#125;&#125; 在上面的例子中，首先初始化变量i为1，然后在for循环里面判断是否小于等于100，如果是的话，输出i，然后再使用i++来将i的值自增1。上面的例子，还有一个更好的写法，就是将i的定义和初始化也放在for里面。如下：1234567891011package mainimport ( "fmt")func main() &#123; for i := 1; i &lt;= 100; i++ &#123; fmt.Println(i) &#125;&#125; 在Go里面没有提供while关键字，如果你怀念while的写法也可以这样：1234567891011121314package mainimport ( "fmt")func main() &#123; var i int = 1 for i &lt;= 100 &#123; fmt.Println(i) i++ &#125;&#125; 或许你会问，如果我要死循环呢？是不是for true？呵呵，不用了，直接这样。123for&#123; ...&#125; 以上就是Go提供的全部控制流程了。 再复习一下，Go只提供了： if1234567if ...&#123; ...&#125;else if ...&#123; ...&#125;else&#123; ...&#125; switch12345678910switch(...)&#123;case ...: ...case ...: ......default: ...&#125; for1234567891011for ...; ...; ...&#123; ...&#125;for ...&#123; ...&#125;for&#123; ...&#125; 数组，切片和字典在上面的章节里面，我们讲过Go内置的基本数据类型。现在我们来看一下Go内置的高级数据类型，数组，切片和字典。 数组(Array)数组是一个具有相同数据类型的元素组成的固定长度的有序集合。比如下面的例子 var x [5]int 表示数组x是一个整型数组，而且数值的长度为5。 Go提供了几种不同的数组定义方法。 最基本的方式就是使用var关键字来定义，然后依次给元素赋值。对于没有赋值的元素，默认为零值。比如对于整数，零值就是0，浮点数，零值就是0.0，字符串，零值就是””，对象零值就是nil。12345678910111213141516171819package mainimport ( "fmt")func main() &#123; var x [5]int x[0] = 2 x[1] = 3 x[2] = 3 x[3] = 2 x[4] = 12 var sum int for _, elem := range x &#123; sum += elem &#125; fmt.Println(sum)&#125; 在上面的例子中，我们首先使用var关键字来声明，然后给出数组名称x，最后说明数组为整型数组，长度为5。然后我们使用索引方式给数组元素赋值。在上面的例子中，我们还使用了一种遍历数组元素的方法。该方法利用Go语言提供的内置函数range来遍历数组元素。range函数可以用在数组，切片和字典上面。当range来遍历数组的时候返回数组的索引和元素值。在这里我们是对数组元素求和，所以我们对索引不感兴趣。在Go语言里面，当你对一个函数返回值不感兴趣的话，可以使用下划线(_)来替代它。另外这里如果我们真的定义了一个索引，在循环结构里面却没有使用索引，Go语言编译的时候还是会报错的。所以用下划线来替代索引变量也是唯一之举了。最后我们输出数组元素的和。 还有一种方式，如果知道了数组的初始值。可以像下面这样定义。12345678910111213141516package mainimport ( "fmt")func main() &#123; var x = [5]int&#123;1, 2, 3, 4&#125; x[4] = 5 var sum int for _, i := range x &#123; sum += i &#125; fmt.Println(sum)&#125; 当然，即使你不知道数组元素的初始值，也可以使用这样的定义方式。1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var x = [5]int&#123;&#125; x[0] = 1 x[1] = 2 x[2] = 3 x[3] = 4 x[4] = 5 var sum int for _, i := range x &#123; sum += i &#125; fmt.Println(sum)&#125; 在这里我们需要特别重视数组的一个特点，就是数组是有固定长度的。 但是如果我们有的时候也可以不显式指定数组的长度，而是使用...来替代数组长度，Go语言会自动计算出数组的长度。不过这种方式定义的数组一定是有初始化的值的。1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var x = [...]string&#123; "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"&#125; for _, day := range x &#123; fmt.Println(day) &#125;&#125; 在上面的例子中，还需要注意一点就是如果将数组元素定义在不同行上面，那么最后一个元素后面必须跟上}或者,。上面的例子也可以是这样的。123456789101112131415161718192021package mainimport ( "fmt")func main() &#123; var x = [...]string&#123; "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", &#125; for _, day := range x &#123; fmt.Println(day) &#125;&#125; Go提供的这种可以自动计算数组长度的方法在调试程序的时候特别方便，假设我们注释掉上面数组x的最后一个元素，我们甚至不需要去修改数组的长度。 切片(Slice)在上面我们说过数组是有固定长度的有序集合。这也就是说一旦数组长度定义，你将无法在数组里面多添加哪怕一个元素。数组的这种特点有的时候会成为很大的缺点，尤其是当数组的元素个数不确定的情况下。 所以切片诞生了。 切片和数组很类似，甚至你可以理解成数组的子集。但是切片有一个数组所没有的特点，那就是切片的长度是可变的。 严格地讲，切片有容量(capacity)和长度(length)两个属性。 首先我们来看一下切片的定义。切片有两种定义方式，一种是先声明一个变量是切片，然后使用内置函数make去初始化这个切片。另外一种是通过取数组切片来赋值。12345678910111213141516171819202122package mainimport ( "fmt")func main() &#123; var x = make([]float64, 5) fmt.Println("Capcity:", cap(x), "Length:", len(x)) var y = make([]float64, 5, 10) fmt.Println("Capcity:", cap(y), "Length:", len(y)) for i := 0; i &lt; len(x); i++ &#123; x[i] = float64(i) &#125; fmt.Println(x) for i := 0; i &lt; len(y); i++ &#123; y[i] = float64(i) &#125; fmt.Println(y)&#125; 输出结果为1234Capcity: 5 Length: 5Capcity: 10 Length: 5[0 1 2 3 4][0 1 2 3 4] 上面我们首先用make函数定义切片x，这个时候x的容量是5，长度也是5。然后使用make函数定义了切片y，这个时候y的容量是10，长度是5。然后我们再分别为切片x和y的元素赋值，最后输出。 所以使用make函数定义切片的时候，有两种方式，一种只指定长度，这个时候切片的长度和容量是相同的。另外一种是同时指定切片长度和容量。虽然切片的容量可以大于长度，但是赋值的时候要注意最大的索引仍然是len(x)－1。否则会报索引超出边界错误。 另外一种是通过数组切片赋值，采用[low_index:high_index]的方式获取数值切片，其中切片元素包括low_index的元素，但是不包括high_index的元素。1234567891011121314151617package mainimport ( "fmt")func main() &#123; var arr1 = [5]int&#123;1, 2, 3, 4, 5&#125; var s1 = arr1[2:3] var s2 = arr1[:3] var s3 = arr1[2:] var s4 = arr1[:] fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(s4)&#125; 输出结果为1234[3][1 2 3][3 4 5][1 2 3 4 5] 在上面的例子中，我们还省略了low_index或high_index。如果省略了low_index，那么等价于从索引0开始；如果省略了high_index，则默认high_index等于len(arr1)，即切片长度。 这里为了体现切片的长度可以变化，我们看一下下面的例子：1234567891011121314151617package mainimport ( "fmt")func main() &#123; var arr1 = make([]int, 5, 10) for i := 0; i &lt; len(arr1); i++ &#123; arr1[i] = i &#125; fmt.Println(arr1) arr1 = append(arr1, 5, 6, 7, 8) fmt.Println("Capacity:", cap(arr1), "Length:", len(arr1)) fmt.Println(arr1)&#125; 输出结果为123[0 1 2 3 4]Capacity: 10 Length: 9[0 1 2 3 4 5 6 7 8] 这里我们初始化arr1为容量10，长度为5的切片，然后为前面的5个元素赋值。然后输出结果。然后我们再使用Go内置方法append来为arr1追加四个元素，这个时候再看一下arr1的容量和长度以及切片元素，我们发现切片的长度确实变了。 另外我们再用append方法给arr1多追加几个元素，试图超过arr1原来定义的容量大小。12345678910111213141516package mainimport ( "fmt")func main() &#123; var arr1 = make([]int, 5, 10) for i := 0; i &lt; len(arr1); i++ &#123; arr1[i] = i &#125; arr1 = append(arr1, 5, 6, 7, 8, 9, 10) fmt.Println("Capacity:", cap(arr1), "Length:", len(arr1)) fmt.Println(arr1)&#125; 输出结果为12Capacity: 20 Length: 11[0 1 2 3 4 5 6 7 8 9 10] 我们发现arr1的长度变为11，因为元素个数现在为11个。另外我们发现arr1的容量也变了，变为原来的两倍。这是因为Go在默认的情况下，如果追加的元素超过了容量大小，Go会自动地重新为切片分配容量，容量大小为原来的两倍。 上面我们介绍了，可以使用append函数给切片增加元素，现在我们再来介绍一个copy函数用来从一个切片拷贝元素到另一个切片。12345678910111213package mainimport ( "fmt")func main() &#123; slice1 := []int&#123;1, 2, 3, 4, 5, 6&#125; slice2 := make([]int, 5, 10) copy(slice2, slice1) fmt.Println(slice1) fmt.Println(slice2)&#125; 输出结果12[1 2 3 4 5 6][1 2 3 4 5] 在上面的例子中，我们将slice1的元素拷贝到slice2，因为slice2的长度为5，所以最多拷贝5个元素。 总结一下，数组和切片的区别就在于[]里面是否有数字或者...。因为数值长度是固定的，而切片是可变的。 字典(Map)字典是一组无序的，键值对的集合。 字典也叫做关联数组，因为数组通过索引来查找元素，而字典通过键来查找元素。当然，很显然的，字典的键是不能重复的。如果试图赋值给同一个键，后赋值的值将覆盖前面赋值的值。 字典的定义也有两种，一种是初始化数据的定义方式，另一种是使用神奇的make函数来定义。123456789101112131415161718package mainimport ( "fmt")func main() &#123; var x = map[string]string&#123; "A": "Apple", "B": "Banana", "O": "Orange", "P": "Pear", &#125; for key, val := range x &#123; fmt.Println("Key:", key, "Value:", val) &#125;&#125; 输出结果为1234Key: A Value: AppleKey: B Value: BananaKey: O Value: OrangeKey: P Value: Pear 在上面的例子中，我们定义了一个string:string的字典，其中[]之间的是键类型，右边的是值类型。另外我们还看到了range函数，此函数一样神奇，可以用来迭代字典元素，返回key:value键值对。当然如果你对键或者值不感兴趣，一样可以使用下划线(_)来忽略返回值。 1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var x map[string]string x = make(map[string]string) x["A"] = "Apple" x["B"] = "Banana" x["O"] = "Orange" x["P"] = "Pear" for key, val := range x &#123; fmt.Println("Key:", key, "Value:", val) &#125;&#125; 上面的方式就是使用了make函数来初始化字典，试图为未经过初始化的字典添加元素会导致运行错误，你可以把使用make函数初始化的那一行注释掉，然后看一下。 当然上面的例子中，我们可以把定义和初始化合成一句。123456789101112131415161718package mainimport ( "fmt")func main() &#123; x := make(map[string]string) x["A"] = "Apple" x["B"] = "Banana" x["O"] = "Orange" x["P"] = "Pear" for key, val := range x &#123; fmt.Println("Key:", key, "Value:", val) &#125;&#125; 现在我们再来看一下字典的数据访问方式。如果你访问的元素所对应的键存在于字典中，那么没有问题，如果不存在呢？ 这个时候会返回零值。对于字符串零值就是””，对于整数零值就是0。但是对于下面的例子：12345678910111213141516package mainimport ( "fmt")func main() &#123; x := make(map[string]int) x["A"] = 0 x["B"] = 20 x["O"] = 30 x["P"] = 40 fmt.Println(x["C"])&#125; 在这个例子中，很显然不存在键C，但是程序的输出结果为0，这样就和键A对应的值混淆了。 Go提供了一种方法来解决这个问题：123456789101112131415161718package mainimport ( "fmt")func main() &#123; x := make(map[string]int) x["A"] = 0 x["B"] = 20 x["O"] = 30 x["P"] = 40 if val, ok := x["C"]; ok &#123; fmt.Println(val) &#125;&#125; 上面的例子中，我们可以看到事实上使用x[&quot;C&quot;]的返回值有两个，一个是值，另一个是是否存在此键的bool型变量，所以我们看到ok为true的时候就输出键C的值，如果ok为false，那就是字典中不存在这个键。 现在我们再来看看Go提供的内置函数delete，这个函数可以用来从字典中删除元素。123456789101112131415161718192021222324package mainimport ( "fmt")func main() &#123; x := make(map[string]int) x["A"] = 10 x["B"] = 20 x["C"] = 30 x["D"] = 40 fmt.Println("Before Delete") fmt.Println("Length:", len(x)) fmt.Println(x) delete(x, "A") fmt.Println("After Delete") fmt.Println("Length:", len(x)) fmt.Println(x)&#125; 输出结果为123456Before DeleteLength: 4map[A:10 B:20 C:30 D:40]After DeleteLength: 3map[B:20 C:30 D:40] 我们在删除元素前查看一下字典长度和元素，删除之后再看一下。这里面我们还可以看到len函数也可以用来获取字典的元素个数。当然如果你试图删除一个不存在的键，那么程序也不会报错，只是不会对字典造成任何影响。 最后我们再用一个稍微复杂的例子来结束字典的介绍。 我们有一个学生登记表，登记表里面有一组学号，每个学号对应一个学生，每个学生有名字和年龄。1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var facebook = make(map[string]map[string]int) facebook["0616020432"] = map[string]int&#123;"Jemy": 25&#125; facebook["0616020433"] = map[string]int&#123;"Andy": 23&#125; facebook["0616020434"] = map[string]int&#123;"Bill": 22&#125; for stu_no, stu_info := range facebook &#123; fmt.Println("Student:", stu_no) for name, age := range stu_info &#123; fmt.Println("Name:", name, "Age:", age) &#125; fmt.Println() &#125;&#125; 输出结果为12345678Student: 0616020432Name Jemy Age 25Student: 0616020433Name Andy Age 23Student: 0616020434Name Bill Age 22 当然我们也可以用初始化的方式定义字典：123456789101112131415161718192021package mainimport ( "fmt")func main() &#123; var facebook = map[string]map[string]int&#123; "0616020432": &#123;"Jemy": 25&#125;, "0616020433": &#123;"Andy": 23&#125;, "0616020434": &#123;"Bill": 22&#125;, &#125; for stu_no, stu_info := range facebook &#123; fmt.Println("Student:", stu_no) for name, age := range stu_info &#123; fmt.Println("Name:", name, "Age:", age) &#125; fmt.Println() &#125;&#125; 输出结果是一样的。]]></content>
      <categories>
        <category>go语言学习笔记</category>
      </categories>
      <tags>
        <tag>go语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摆渡人]]></title>
    <url>%2F2017%2F07%2F05%2FFerryMan%2F</url>
    <content type="text"><![CDATA[《摆渡人》是英国著名实力作家—克莱儿.麦克福尔的著作，凭借此著作，她一举获得了五项世界文学大奖。故事发生在神话背景下，以穿越荒原为主线，展现了人物灵魂成长的踪迹。 迪伦一个15岁单亲女孩，一直跟妈妈生活，与父亲久未谋面。她烦恼母亲的喋喋不休，厌恶学校的环境。为了逃离这一切，她踏上了去见父亲的列车。不曾想到的是，火车出事故了，她成了唯一的幸存者，或者说是唯一的遇难者。初始，迪伦还是个孩子，担忧早饭的好坏，恐惧同学的嘲笑，尤其是在选择是否带上泰迪熊上火车的时候，几次拿起，放下，取出，放进，作者细腻的笔触，充分展示了一个小女孩心理世界的脆弱，恐惧，犹疑不安。此时，她心中是一片荒原，唯有爱，可以浇灌它茂密生长。 崔斯坦一个灵魂摆渡人，不知道从何时开始从事这份工作，他引领了成百上千，成千上万的灵魂。他一直认为：这是命，他没得选择。最初，他工作热情投入，后来经历了很多灵魂的自私，贪婪，工作渐渐成了例行公事。故事的开篇，他疲惫的坐在那儿，冷漠的应对。他的心，又何尝不是一片荒原呢？ 第一眼看到《摆渡人》的封面便被吸引，阳光照耀下，静谧的湖水，一叶小舟飘行，头顶是滚滚的乌云，湖水被金色阳光映衬着，闪着温暖的光芒，而阳光的尽头是乌黑翻滚的水波。这似乎是一个人的心灵或者是主人公迪伦的灵魂深处，身处黑暗，却总有一片光明在牵引着她不断前行，这片光明便是她心底因爱而生的倔强信念。 第一章节迪伦出现在火车站，下着雨，她焦急的等着晚点的火车。她回忆这一天的倒霉事儿，却不知道其实死亡正悄悄靠近。火车钻入山洞，是的，这是事故地点。她惊恐的穿越漆黑的火车通道，费力打开车门，穿行在山洞中，恐惧布满全身。千辛万苦钻出山洞，却失望的发现，一无所有，没有想象中的人群，救护车。她渴望着，希冀有一丝文明的迹象，向四周眺望的时候，她发现了他。 这是他们第一次相遇，他抱膝坐在那儿，看着迪伦没有一丝笑意。迪伦如释重负的眼含热泪，庆幸：她不再是孤单一人。此时作者重点叙述迪伦的弱小，单纯。“崔斯坦突然站起来往前走，而迪伦嘴张了几下，却一个音也发不出来，她愣在那里一动不动。他用指挥官一样的口吻命令：跟我走。”虽不是完全情愿，迪伦却像被催眠了，跟随着他移动。 在这片荒原，他是她灵魂的摆渡人，他引领她回家。他们穿过树林，木丛，翻越大山，勇斗恶魔，途经一个个安全小屋。如果之前迪伦的心是干涸的河床，那么跟随他们的脚步，跟随克莱儿的叙述，爱将一点一滴的蓄满。 他们白天赶路，晚上住在山中小屋，如果不及时进入安全小屋，地底的恶魔便会吞噬灵魂，使之魂飞魄散，变成恶魔。 抵达第一个安全小屋的时候，迪伦仍然是恐惧，不情愿的，她只是不敢一个人面对那些未知的危险。 第二个小屋，迪伦已经了然事实真相，原来她是在火车上唯一一个没有逃脱的，因为她已经死了，所以来到这片荒原，这里的一切都是她心像的投射。迪伦的平静出乎崔斯坦的预料，他开始对这个小女孩侧目。是的，迪伦很平静，似乎有着回家的安宁，因为她知道，摆渡人会引领，保护她。 穿行在荒原上，共同抵抗着恶魔的侵袭，迪伦习惯于崔斯坦的陪伴，完全信任于他。她开始关心他，担心他会因为自己不经意好奇的话而受伤；崔斯坦很久以来第一次为自己的命运黯然神伤。荒原之上，有一粒种子悄然生根发芽。 迪伦奋力冲进第四个安全屋时，发现崔斯坦不见了，他在跟恶魔的斗争中消失了。她撕心裂肺的哭，直到没有一丝力气，仍然执着的望着门口。“她从地上坐起来，肌肉一阵剧痛，她不由得发出一声呻吟。她仍然不敢把目光从门口挪开”。“崔斯坦，我需要你”她的嗓音嘶哑，泪花滚动。细节的描述透漏了少女的心，她已经爱上他。等到崔斯坦终于回来的时候，她忘乎所以的拥抱，沉浸在无尽的安心和喜悦中。 随着时间的推移，他们离分界线越来越近，心灵也越来越煎熬。她将去到另外一个世界，而他去不了那里，他会永远消失在她的生命中。明明相爱，却没有结果，懂得规则的崔斯坦承受了更大的煎熬，他既不想伤害她，实话实说，又怕她会伤心，不忍拒绝。 最后一天还是来临了，这些天在崔斯坦的保护，安慰，引领下，迪伦不再是那个脆弱的小女孩，她更加成熟，更加坚定，她可以勇敢的直面内心的恐惧。她坦率的说出：我爱你。崔斯坦回头看着她，内心矛盾纠结极了，他也一心一意的爱着她，只是不知道该不该表白。最终，他还是没能敌过自己的心：我也爱你，迪伦。“她注视他片刻，最后僵在那里。慢慢咀嚼他的话，心在欢喜的跳跃。分界线前的拥吻是那样的甜蜜和温暖，如同清澈的湖水，填满迪伦曾经匮乏的心，爱的阳光越来越明亮。因了这份明亮，她毅然的在另一个世界探索回来的路途，坚定的决定大海捞针的搜索。 如果再次回到荒原，她有可能再次死亡，彻底的魂飞魄散，是留是回，迪伦也曾犹豫，只是当想到崔斯坦钴蓝色的眼睛，及带给她的浓浓温暖，她坚决选择了“时不待我“，立即出发。 途径那片湖泊，水底的怪兽，合力围攻她，她就要放弃了。“崔斯坦的面庞在她脑海浮现，无比清晰，这让她又有了继续斗争的力量”。山路上行走，她摒弃一切杂念，克服本能的恐惧，低头前行，她必须这样做，不能看那些恶魔，一旦看了，就会被吞噬。恶魔轮番的偷袭，企图扰乱她的意志力。恶魔得到可乘之机时，一齐向她袭来，就在她惊慌失措的时候，崔斯坦的面容又一次浮现在眼前，迪伦变的充满斗志。 在他们住过的小木屋前，迪伦终于又见到了崔斯坦，“迪伦笑了，大口吸气，好像自从他离开之后自己就没有再呼吸过。”“她欣喜若狂的奋力挥手”。崔斯坦也看到了她，惊愕，恐惧，还有欣喜，他从来不敢奢望，他们还能再见面。 相逢之后的迪伦，彻彻底底的改变，她勇敢无畏。为了救助一个小女孩的灵魂，她义无反顾的冲出安全屋，机智的与恶魔搏斗，克莱儿以此展现出迪伦的涅槃蜕变。 迪伦“双臂交叉放在胸口，脸上带着不达目的誓不罢休的表情”。而此时的崔斯坦却犹豫起来“我没有选择……我是说，我没有自由选择的权利，我的双腿，它们并不属于我。”迪伦不停的鼓励崔斯坦做一下尝试。为里爱，为了他们，尝试一起回到迪伦之前的世界。虽然规则一直是这样的，但是也许，也许他们还是有一线希望的。 迪伦的心中有一轮太阳，一轮信念和爱的太阳。她坚持拖着崔斯坦返程。跋山涉水，他们再次回到火车事故地点。 迪伦苏醒的时候，已经被救援的人发现，而让人担心的崔斯坦呢？开始，她以为他消失了，不停的自责。幸运的是，在出口，她看到了他，仍然坐在出口的左侧。他们再次相逢在新的世界。彼此打招呼“嗨，原来你在这里。” 初读之下，感觉这是一部关于爱情的小说，细细咀嚼，它是一个小女孩的心灵成长史。因为爱的匮乏，她的心是一片无尽的荒原；穿越之后，因为爱的丰盛，她蜕变成一个勇敢坚强的摆渡人，将自己的爱人引领回家，脱离无形的控制。 犹如书的封面，无论如何黑暗，有爱的阳光，一切都会好的。即使是荒原，也会肆意长满茂密的绿色。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心灵救赎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在回忆]]></title>
    <url>%2F2017%2F07%2F05%2FmyMemory%2F</url>
    <content type="text"><![CDATA[我在回忆，在珍惜，在憧憬 回忆 在爱人的眼里，一千里的距离不过一里。是距离让我们的心更靠近。我们的爱情，经历了信任、猜疑、信任、猜疑…最后我们还是选择了信任。我感谢你。 懵懂青春三年前 &#160; &#160; &#160; &#160; 在经历了那段不顾一切的奋斗之后，我们都喜欢上了对方，可是当我们想去橘子林大吃一顿的时候，发现橘子已经过了收成的时段，我们的爱情赶上了毕业季的分离，还没有吃上甜美的橘子，上天却告诉我们已经没有橘子卖了。只是还是忘不了那好像命中注定的你总是要坐到我旁边几个位置，让我抬头就可以注意到你；忘不了你在操场在我后方不远处的高喊，我随意的回了一句“现在不合适”；忘不了高考前一天我对你的表白短信“我喜欢你”，和你的简短回应“我也喜欢你”；忘不了高考后你拉着我逃离那个无聊的KTV，我们两个在中州公园漫无目的的散步，然后你一直拿湿纸巾擦我的手，那么地细心；忘不了我们在那个饭店吃中午饭，我们都笑着说“这算不算是离别饭”，我们都没有用“分手”两个字；忘不了那天我不知道怎么了抽风似的，送了你一大盒包装极其丑陋的巧克力，你还不好意思的差点笑出来；忘不了那天我们要收拾东西回去的时候，你敲了敲门问“刘韬在吗？”，我就和你一起来到了天台，那是我第一次也是最后一次从背后抱你，因为我没有从正面抱你的勇气。忘不了你对我说我是在和你玩暧昧，我不爱你，之后就渐渐的疏远，谁也不低头。 历历在目三年中 &#160; &#160; &#160; &#160; 在经历了和你分离之后，我很长一段时间里都在失恋中度过，不，不算失恋，就像你说的，我们只是暧昧吧。可是我不知道为什么会这么心痛，从表白到分离只用了一个月。一个月，对于巨蟹座的我来说这是多么的深刻，深刻地每时每刻心里都插了一把刀子。我忘不了这种初恋的感觉，也许对于你来说，这都不算是恋爱，可是我就是认真了，我就觉得是，那就是恋爱，就是恋爱，是恋爱。 &#160; &#160; &#160; &#160; 来到大学后，我“逗比”地在墙上贴上所有我暗恋过的女生和唯一恋爱过的你，我还在骗自己，这就是恋爱。并在你的名字后面写上一句“男人的精力是用来奋斗的，不是用来射的”，之后，我就有了一大堆的“逗比”外号。正如周星驰的搞笑手法一样，和同学一起笑过之后，是那对比强烈的落寞。我无聊，我落寞，我孤单，我还是忘不了。 &#160; &#160; &#160; &#160; 那天起来，看到你的QQ头像是和你前男友的合影，我开始看不起你，觉得这个世界我不懂。我已经不记得了我曾经多少次在QQ上默默的给你发了几个“在吗？”；已经不记得了我曾经多少次在教室里寻找，希望可以找到那个像你的身影；已经不记得了我曾经多少次在旅途中想象在我身边的人是你；已经不记得了我曾经多少次拿起电话想打给你有放下电话；我已经不记得了我曾经多少次在操场上跑步幻想在前面跑的那个人是你；我已经不记得了我曾经多少次……其实这些我都还记得，对，我记得，历历在目。只不过远方的你不知道我曾经的多少次。&#160; &#160; &#160; &#160; 我不想知道你为什么还要来联系我，我也不想知道你在大学里两年都发生了什么事情，一切我都不想知道，我还知道什么，我什么都不知道。我只知道在大二的时候，你终于联系我了，联系我了，联系我了。你问我在学校有没有找女朋友，说要给我介绍女朋友，我回答“好啊，谁呀？”。我有一种预感那个人就是你，结果真的说是“我怎么样”。你知道这是一种什么样的感觉吗，就像一个人被冤入狱两年，之后告诉你无罪释放。我试着去想，试着去做的更好。可是，两颗心分离两年，我要怎么去懂你，你要怎么去懂我。你总是缺乏安全感，你总是缺少信任，我不知道你的成长环境，我不知道你大学里的一切，我猜不透你。&#160; &#160; &#160; &#160; 之后我们就这样“撕逼”了一学期，没有把时间用在了解对方上，而是在争论“你到底爱我吗”这样的问题上。可以说 证明“我爱你”是一道数学题，得出结论是需要过程的，没有过程的解答是没有分数的。这个过程就是我要用最快的时间来了解一颗我两年未曾见到的那颗心，可是不知道是题目太难，还是时间不够，也许更可能是我不够聪明吧。我题目还没解完就被你这个监考老师说时间到了，要交卷了，要交卷了，要交卷了。可是我还没有证明出来！如何证明“我爱你”让我焦虑，让我迷茫，让我心痛。我想放弃了，真的想放弃了，真的。为什么证明“我爱你”这道题 一定要有时间限制，让我用一生来证明不可以吗？对，用一生来证明，哼，也许你会想“谁会用一生时间来赌你的证明题”。你需要你的爱来的急切，恨不得立马就有人爱你不离不弃。阿甘正传里面阿甘 曾经说过一句话“我不是一个聪明的人，但我知道什么是爱”，阿甘是一个木讷的人，可是他的爱是真诚，是执着，是坚守。我们都不知道，都不知道，都不知道。 雨过天晴三年后&#160; &#160; &#160; &#160; 那个暑假，陪伴我的有乐山大佛，西安城墙，大雁塔，秦始皇兵马俑，山东济南趵突泉，还有最重要的大明湖，以及我的夏雨荷。我的夏雨荷，等你，是给你最长的情书。夏雨荷曾经说过“等了一辈子,恨了一辈子,想了一辈子,怨了一辈子,可是仍然感激上苍,让我有这个可等,可恨,可想,可怨的人,否则,生命就像一口枯井,了无生趣”。我在想你，我在等你，你在哪里？我在朋友圈中发出我说说“等到了大明湖，却等不到我的夏雨荷”，我只想让你看见，只想让你知道我离你6个小时车程的地方想你。你把我删了，删了，删了。我鼓起勇气再给你发出好友请求。我们又联系上了。我这次不会再放过你，绝不！&#160; &#160; &#160; &#160; 我陪着你度过了那个折磨你的一学期，你在考研，也是对我的考验。因为，我相信只要我真心相待，你一定会懂。你一定不知道我很心疼你，在无数个你12点睡，6点起；你一定不知道我很心疼你，在你哭着和我说你来不及准备；你一定不知道我很心疼你，在你每天累的睁不开眼还要和我通电话；你一定不知道我很心疼你，在你每次和我视频，躲在潮湿的晾衣间，还说那里信号比较好；你一定不知道我很心疼你，在你每次在食堂吃的那些没营养的面条，说自己没胃口；你一定不知道我很心疼你，在你每次冒着零下十几度从宿舍跑到图书馆，那股执着劲；你一定不知道我很心疼你……。&#160; &#160; &#160; &#160; 感谢上天，终于让你的努力有了回报。这也许是对我最大的恩赐。我们终于见面了，见面了，见面了。 珍惜犹抱琵琶半遮面&#160; &#160; &#160; &#160; 我坐了几个小时的火车终于到达了约定的地点，我坐立不安，因为我即将面对那个我朝思暮想的你。你来了，就这样来了，我猝不及防。你害羞，你低头，你偷偷的看我，偷偷的，别以为我不知道，我全都知道。我知道你因为害羞，所以吃饭的时候一直盯着手机；我知道你因为害怕自己的身高，所以一定要穿高跟鞋过来；我知道你因为担心自己脸大，一直想剪个刘海；我知道你因为不想让自己显得朴素，所以穿了一件五颜六色的大衣过来；我知道你……，是因为你爱我。&#160; &#160; &#160; &#160; 我不知道那天发生了什么，我真的不知道。我只记得那种感觉，那种重生的感觉。你的舌头，柔软甜美，每一次都好像想卷走我的心脏；&#160; &#160; &#160; &#160; 你的泪水，晶莹剔透，每一滴都可以融化整个我；&#160; &#160; &#160; &#160; 你的呼喊，温柔细腻，每一声都可以让我欲生欲死。&#160; &#160; &#160; &#160; 我吻过你的美唇；&#160; &#160; &#160; &#160; 我和你耳鬓厮磨；&#160; &#160; &#160; &#160; 我抚过你的香肩；&#160; &#160; &#160; &#160; 我和你暗夜缠绵；&#160; &#160; &#160; &#160; 我舔过你的玉峰；&#160; &#160; &#160; &#160; 我和你水乳交融；&#160; &#160; &#160; &#160; 我划过你的酥背；&#160; &#160; &#160; &#160; 我和你共赴巫山；&#160; &#160; &#160; &#160; 我贴过你的圆臀；&#160; &#160; &#160; &#160; 我和你鱼水之欢。&#160; &#160; &#160; &#160; 在这个瞬间，我似乎明白了‘永远’、‘心’和‘灵魂’的意义之所在，强烈的情感让我想将这三年所经历的全部都与你分享。然后在下一个瞬间——却又悲伤得无法抑制。因为我即将又要离开你。 明朝相忆路漫漫&#160; &#160; &#160; &#160; 明知分离苦，相见也难阻；那一夜，我们哭了好几次，你不愿意跟我提分离的事。因为怕我丢失，怕我不见。离别，能使浅薄的感情削弱，却使深挚的感情更加深厚，正如风能吹灭烛光，却会把火扇得更旺。后视镜里的视线，越来越远的道别。没有来得及KISS GOODBAY；我哭的像个孩子，像个孩子，像个孩子。&#160; &#160; &#160; &#160; 前度小花静院，不比寻常时见。&#160; &#160; &#160; &#160; 见了又还休，愁却等闲分散。&#160; &#160; &#160; &#160; 肠断，肠断，&#160; &#160; &#160; &#160; 记取钗横鬓乱。 憧憬&#160; &#160; &#160; &#160; 暂别紫台自飘摇，何惧风雪总潇潇。不见昨夜雨湿处，聊以新颜待今朝。周杰伦有首歌叫《回到过去》，而我却要和你走到未来。未来只有你才会更美好。过去的由我来承受，现在的我们一起珍惜，未来的想牵着你的手一起来过。]]></content>
      <categories>
        <category>生活小记</category>
      </categories>
      <tags>
        <tag>那些年，那些事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于武汉的记忆]]></title>
    <url>%2F2017%2F07%2F05%2Faboutwuhan%2F</url>
    <content type="text"><![CDATA[爱情的奇妙在于，说分手的那个偏偏爱着，不爱的那个用沉默回答。天天害怕失去的那个人最先离开。你是这个世界给我的情书，也是爱情的遗书。 关于武汉我知道的不多，为了爱情曾经去过那里多少次火车上路过这城市，一个人悄悄的想起你你说你喜欢武汉冬天的阳光，巷子里飘满热干面的味道江风穿过你年轻的脖子，直到今天都没有散去关于武汉我想的全是你，想来想去都是忏悔和委屈关于武汉我爱的全是你，爱来爱去不明白爱的意义关于武汉只是经常想起，现在你的味道都在回忆里每次和朋友说起过去的旅行，我不敢说我曾经去过那里关于武汉我爱的全是你，爱到最后我们都无路可去似是而非或是世事可畏，有情有义又或是无米之炊时间改变了很多又什么都没有，让我再一次拥抱你]]></content>
      <categories>
        <category>生活小记</category>
      </categories>
      <tags>
        <tag>那些年，那些事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[初等算法]--树]]></title>
    <url>%2F2017%2F04%2F03%2FbasicAlg01%2F</url>
    <content type="text"><![CDATA[二叉搜索树,数据结构中的”hello world”我们使用二叉搜索树(BST)作为数据结构中的“hello world”。Jon Bentley在他的《编程珠玑》一书中,曾给了这样一个有趣的题目:如何统计一段文字中每个单词出现的次数?下面的C++程序展示了一个解法。123456789int main(int, char∗∗ )&#123; map&lt;string, int&gt; dict; string s; while(cin&gt;&gt;s) ++dict[s]; map&lt;string, int&gt;::iterator it=dict.begin(); for(; it!=dict.end(); ++it) cout&lt;&lt;it-&gt;first&lt;&lt;": "&lt;&lt;it-&gt;second&lt;&lt;"λn";&#125; C++标准库中提供的map是一种用平衡二叉树实现的字典数据结构。例子中用单词作为key,用单词出现的次数作为值。一棵二叉搜索树是一棵满足下面条件的二叉树: 所有左侧分支的值都小于本节点的值, 本节点的值小于所有右侧分支的值。 节点数据结构123456789101112template&lt;class T&gt;struct node&#123; node(T x):key(x), left(0), right(0), parent(0)&#123;&#125; ~node()&#123; delete left; delete right; &#125; node∗ left; node∗ right; node∗ parent; //Optional, it's helpful for succ and pred T key;&#125;; 插入我们可以使用下述算法向一个二叉搜索树中插入一个键k(在实际应用中,有时会同时插入一对键和值): 如果树为空,创建一个叶子节点,令该节点的key = k; 如果k小于根节点的key,将它插入到左子树中; 如果k大于根节点的key,将它插入到右子树中。 遍历遍历是指依次访问二叉树中的每个元素。有三种遍历方法,分别是前序遍历、中序遍历和后序遍历。它们是按照访问根节点和子节点的先后顺序命名的。 前序遍历:先访问key,然后访问左子树,最后访问右子树; 中序遍历:先访问左子树,然后访问key,最后访问右子树; 后序遍历:先访问左子树,然后访问右子树,最后访问key。 所有的“访问”操作都是递归的。先访问根后访问子分支称为先序,在访问左右分支的中间访问根称为中序,先访问子分支后访问根称为后序。对于图中的二叉树,下面分别列出了三种遍历的结果: 前序遍历:4, 3, 1, 2, 8, 7, 16, 10, 9, 14; 中序遍历:1, 2, 3, 4, 7, 8, 9, 10, 14, 16; 后序遍历:2, 1, 3, 7, 9, 14, 10, 16, 8, 4。 对二叉搜索树进行中序遍历,元素就会按照从小到大的顺序输出。中序遍历的算法可以描述为: 如果树为空,则返回; 否则先中序遍历左子树,然后访问key,最后再中序遍历右子树。 搜索Look up二叉搜索树的定义使得它非常适合进行元素的搜索。可以按照下面描述的方法在树中搜索一个key: 如果树为空,搜索失败; 如果根节点的key等于待搜索的值,搜索成功,返回根节点作为结果; 如果待搜索的值小于根节点的key,继续在左子树中递归搜索; 否则,待搜索的值大于根节点的key,继续在右子树中递归搜索。 12345678template&lt;class T&gt;node&lt;T&gt;∗ search(node&lt;T&gt;∗ t, T x)&#123; while(t &amp;&amp; t-&gt;key!=x)&#123; if(x &lt; t-&gt;key) t=t-&gt;left; else t=t-&gt;right; &#125; return t;&#125; 最小元素和最大元素为了获取最小元素,我们可以不断向左侧前进,直到左侧分支为空。类似地,我们可以通过不断向右侧前进获取最大元素。 前驱(Successor)和后继(predecessor)给定元素x,它的后继元素y是满足y &gt; x的最小值。有两种情况:如果x所在的节点有一个非空的右子树,则右子树中的最小值就是答案。如图所示,8的后继元素为9,它是元素8的右子树中的最小值。另外一种情况是,如果x没有非空的右子树,我们需要向上回溯,找到最近的一个祖先,使得该祖先的左侧孩子,也为x的祖先。元素2所在的节点没有右侧分支,我们向上回溯一步找到元素1,但是1没有左侧分支,因此需要继续向上查找,这次我们到达了元素3所在的节点。而3的左侧孩子,同样也是2的祖先。至此,我们找到了2的后继元素3。1234567891011121314def succ(x): if x.right is not None: return tree_min(x.right) p = x.parent while p is not None and p.left != x: x = p p = p.parent return pdef pred(x): if x.left is not None: return tree_max(x.left) p = x.parent while p is not None and p.right != x: x = p p = p.parent return p 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;sstream&gt;//#include &lt;boost/lambda/lambda.hpp&gt;template&lt;class T&gt;struct node&#123; node(T x):key(x), left(0), right(0), parent(0)&#123;&#125; ~node()&#123; // for convinient, use functional approach delete left; delete right; &#125; node* left; node* right; node* parent; //parent is optional, it's helpful for succ/pred T key;&#125;;// in-order tree walk// easy implemented by using functional approachtemplate&lt;class T, class F&gt;void in_order_walk(node&lt;T&gt;* t, F f)&#123; if(t)&#123; in_order_walk(t-&gt;left, f); f(t-&gt;key); in_order_walk(t-&gt;right, f); &#125;&#125;template&lt;class T&gt;node&lt;T&gt;* search(node&lt;T&gt;* t, T x)&#123; while(t &amp;&amp; t-&gt;key!=x)&#123; if(x &lt; t-&gt;key) t=t-&gt;left; else t=t-&gt;right; &#125; return t;&#125;template&lt;class T&gt;node&lt;T&gt;* min(node&lt;T&gt;* x)&#123; while(x &amp;&amp; x-&gt;left) x = x-&gt;left; return x;&#125;template&lt;class T&gt;node&lt;T&gt;* max(node&lt;T&gt;* x)&#123; while(x &amp;&amp; x-&gt;right) x = x-&gt;right; return x;&#125;template&lt;class T&gt;node&lt;T&gt;* succ(node&lt;T&gt;* x)&#123; if(x)&#123; if(x-&gt;right) return min(x-&gt;right); //find an ancestor, whose left child contains x node&lt;T&gt;* p = x-&gt;parent; while(p &amp;&amp; p-&gt;right==x)&#123; x = p; p = p-&gt;parent; &#125; return p; &#125; return 0;&#125;template&lt;class T&gt;node&lt;T&gt;* pred(node&lt;T&gt;* x)&#123; if(x)&#123; if(x-&gt;left) return max(x-&gt;left); //find an ancestor, whose right child contains x node&lt;T&gt;* p = x-&gt;parent; while(p &amp;&amp; p-&gt;left==x)&#123; x = p; p = p-&gt;parent; &#125; return p; &#125; return 0;&#125;template&lt;class T&gt;node&lt;T&gt;* insert(node&lt;T&gt;* tree, T key)&#123; node&lt;T&gt;* root(tree); node&lt;T&gt;* x = new node&lt;T&gt;(key); node&lt;T&gt;* parent(0); while(tree)&#123; parent = tree; if(key &lt; tree-&gt;key) tree = tree -&gt; left; else //assert there is no duplicated key inserted. tree = tree -&gt; right; &#125; x-&gt;parent = parent; if( parent == 0 ) //tree is empty return x; else if( key &lt; parent-&gt;key) parent-&gt;left = x; else parent-&gt;right = x; return root;&#125;// cut the node off the tree, then delete it.// it can prevent dtor removed children of a nodetemplate&lt;class T&gt;void remove_node(node&lt;T&gt;* x)&#123; if(x) x-&gt;left = x-&gt;right = 0; delete x;&#125;// The algorithm described in CLRS isn't used here.// I used the algorithm as below (refer to Annotated STL, P 235 (by Hou Jie)// if x has only one child: just splice x out// if x has two children: use min(right) to replace x// @return root of the treetemplate&lt;class T&gt;node&lt;T&gt;* del(node&lt;T&gt;* tree, node&lt;T&gt;* x)&#123; if(!x) return tree; node&lt;T&gt;* root(tree); node&lt;T&gt;* old_x(x); node&lt;T&gt;* parent(x-&gt;parent); if(x-&gt;left == 0) x = x-&gt;right; else if(x-&gt;right == 0) x = x-&gt;left; else&#123; node&lt;T&gt;* y=min(x-&gt;right); x-&gt;key = y-&gt;key; if(y-&gt;parent != x) y-&gt;parent-&gt;left = y-&gt;right; else x-&gt;right = y-&gt;right; remove_node(y); return root; &#125; if(x) x-&gt;parent = parent; if(!parent) root = x; //remove node of a tree else if(parent-&gt;left == old_x) parent-&gt;left = x; else parent-&gt;right = x; remove_node(old_x); return root;&#125;//for testingtemplate&lt;class Coll&gt;node&lt;typename Coll::value_type&gt;* build_tree(const Coll&amp; coll)&#123; node&lt;typename Coll::value_type&gt;* tree(0); for(typename Coll::const_iterator it=coll.begin(); it!=coll.end(); ++it) tree = insert(tree, *it); return tree;&#125;template&lt;class T&gt;std::string tree_to_str(const node&lt;T&gt;* tree)&#123; if(tree)&#123; std::ostringstream s; s&lt;&lt;"("&lt;&lt;tree_to_str(tree-&gt;left)&lt;&lt;"), "&lt;&lt;tree-&gt;key &lt;&lt;", ("&lt;&lt;tree_to_str(tree-&gt;right)&lt;&lt;")"; return s.str(); &#125; return "empty";&#125;template&lt;class T&gt;node&lt;T&gt;* clone_tree(const node&lt;T&gt;* t, node&lt;T&gt;* parent=0)&#123; if(t)&#123; node&lt;T&gt;* t1 = new node&lt;T&gt;(t-&gt;key); t1-&gt;left = clone_tree(t-&gt;left, t1); t1-&gt;right = clone_tree(t-&gt;right, t1); t1-&gt;parent = parent; return t1; &#125; return static_cast&lt;node&lt;T&gt;*&gt;(0);&#125;//test helperclass test&#123;public: test()&#123; const int buf[]=&#123;15, 6, 18, 3, 7, 17, 20, 2, 4, 13, 9&#125;; tree = build_tree(std::vector&lt;int&gt;(buf, buf+sizeof(buf)/sizeof(int))); std::cout&lt;&lt;tree_to_str(tree); &#125; ~test()&#123; delete tree; &#125; template&lt;class T&gt; void assert_(std::string msg, T x, T y)&#123; std::cout&lt;&lt;msg; if(x==y) std::cout&lt;&lt;x&lt;&lt;" OK.\n"; else std::cout&lt;&lt;x&lt;&lt;"!="&lt;&lt;y&lt;&lt;" Fail.\n"; &#125; void run()&#123; test_in_order_walk(); test_min_max(); test_search(); test_succ_pred(); test_del(); &#125;private: struct Print&#123; template&lt;class T&gt; void operator()(T x)&#123; std::cout&lt;&lt;x&lt;&lt;", "; &#125; &#125;; void test_in_order_walk()&#123; std::cout&lt;&lt;"\ntest in order walk with print functor: "; in_order_walk(tree, Print()); //this can be simplified by using boost //using namespace boost::lambda; //in_order_walk(tree, std::cout&lt;&lt;_1&lt;&lt;", "); &#125; void test_min_max()&#123; node&lt;int&gt;* empty(0); assert_("min(empty)=", min(empty), empty); assert_("min(tree)=", min(tree)-&gt;key, 2); assert_("max(empty)=",max(empty), empty); assert_("max(tree)=", max(tree)-&gt;key, 20); &#125; void test_search()&#123; node&lt;int&gt;* empty(0); assert_("search empty: ", search(empty, 3), empty); std::cout&lt;&lt;"search exist key: "&lt;&lt;tree_to_str(search(tree, 18))&lt;&lt;"\n"; assert_("search non-exist: ", search(tree, 5), empty); &#125; void test_succ_pred()&#123; node&lt;int&gt;* empty(0); assert_("succ 7: ", succ(search(tree, 7))-&gt;key, 9); assert_("succ 13: ", succ(search(tree, 13))-&gt;key, 15); assert_("succ 20: ", succ(search(tree, 20)), empty); assert_("pred 6: ", pred(search(tree, 6))-&gt;key, 4); assert_("pred 7: ", pred(search(tree, 7))-&gt;key, 6); assert_("pred 2: ", pred(search(tree, 2)), empty); &#125; void test_del_n(int n)&#123; node&lt;int&gt;* empty(0); node&lt;int&gt;* t1=clone_tree(tree); t1=del(t1, search(t1, n)); std::cout&lt;&lt;"del "&lt;&lt;n&lt;&lt;":\n"&lt;&lt;tree_to_str(t1)&lt;&lt;"\n"; assert_("search after del: ", search(t1, n), empty); delete t1; &#125; void test_del()&#123; test_del_n(17); test_del_n(7); test_del_n(6); test_del_n(15); test_del_n(1); //try to del a non-exist val &#125;private: node&lt;int&gt;* tree;&#125;;int main(int, char**)&#123; test().run();&#125; 插入排序的进化123456void isort(Key∗ xs, int n)&#123; int i, j; for(i=1; i&lt;n; ++i) for(j=i-1; j≥0 &amp;&amp; xs[j+1] &lt; xs[j]; --j) swap(xs, j, j+1);&#125; 改进一任何时刻,我们手中的牌都是已序的,因此我们可以用二分查找来搜索插入位置。123456789101112131415161718192021def isort(xs): n = len(xs) for i in range(1, n): x = xs[i] p = binary_search(xs[:i], x) for j in range(i, p, -1): xs[j] = xs[j-1] xs[p] = xdef binary_search(xs, x): l = 0 u = len(xs) while l &lt; u: m = (l+u)/2 if xs[m] == x: return m elif xs[m] &lt; x: l = m + 1 else: u = m return l 使用二叉搜索树的最终改进12345function Sort(A) T &lt;- φ for each x ∈ A do T &lt;- Insert-Tree(T, x) return To-List(T)]]></content>
      <categories>
        <category>初等算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[初等算法]--前言]]></title>
    <url>%2F2017%2F04%2F03%2FbasicAlg00%2F</url>
    <content type="text"><![CDATA[最小可用ID 算法的威力题目：系统中每一个ID具有独特性，有些ID处于使用的状态，有些ID可以分配给新的用户，现在的问题是，怎么样找到最小的可用ID呢？当前正在使用的ID： [18, 4, 8, 9, 16, 1, 14, 7, 19, 3, 0, 5, 2, 11, 6] 解法一：暴力搜索我们立即可以写出下面的解法：123456def brute_force ( lst ): i = 0 while True : if i not in lst : return i i = i + 1 在个解法在一个几百万个ID系统中表现的性能很差，需要O(N*N)的时间。 解法二：时间优化改进这一解法的关键基于这一事实:对于任何n个非负整数x 1 , x 2 , …, x n ,如果存在小于n的可用整数,必然存在某个x i 不在[0, n)这个范围内。否则这些整数一定是0, 1, …, n − 1的某个排列,这种情况下,最小的可用整数是n。1234567def min_free(A): n = len(A) a = [0]*(n+1) for x in A: if x &lt; n: a[x] = 1; return a.index(0); 缺点：空间上有浪费。 解法三：分而治之我们在速度上的改进是以空间上的消耗为代价的。由于维护了一个长度为n的标志数组,当n很大时,空间上的性能就成了新的瓶颈。分而治之的典型策略是将问题分解为若干规模较小的子问题,然后逐步解决它们以得到最终的结果。我们可以将所有满足xi ≤ ⌊n/2⌋的整数放入一个子序列A′;将剩余的其他整数放入另外一个序列A′′。根据公式1,如果序列A′ 的长度正好是⌊n/2⌋,这说明前一半的整数已经“满了”,最小的可用整数一定可以在A′′中递归地找到。否则,最小的可用整数可以在A′中找到。总之,通过这一划分,问题的规模减小了。 需要注意的是,当我们在子序列A′′ 中递归查找时,边界情况发生了一些变化,我们不再是从0开始寻找最小可用整数,查找的下界变成了⌊n/2⌋ + 1。因此我们的算法应定义为minfree(A, l, u),其中l和u分别是上下界。递归结束的边界条件是当待查找的序列变为空的时候,此时我们只需要返回下界作为结果即可。12345678910111213def dc_min_free(lst): return binary_search(lst, 0, len(lst)-1)def binary_search(lst, l, u): if lst == []: return l m = (l + u ) / 2 xs = [x for x in lst if x &lt;= m] ys = [x for x in lst if x &gt; m] if len(xs) == m - l + 1: return binary_search(ys, m+1, u) else: return binary_search(xs, l, m) 时间复杂度为O(n)，空间复杂度为O(logn)。 丑数 数据结构的威力如果说最小可用ID问题还有一些应用价值,那么接下来这个问题就纯粹是为了“有趣”了。我们要寻找第1500个“丑数”。所谓丑数,就是只含有2、3或5这三个因子的自然数。前三个丑数按照定义分别是2、3和5。数字60 = 2x2x3x5是第25个丑数。数字21 = 3x7 由于含有因子7,所以不是丑数。前10个丑数如下表:2,3,4,5,6,8,9,10,12,15如果我们认为1也是一个合法的丑数,则1就是第一个丑数。 暴力解法这道题目看起来并不复杂,我们可以从1开始,逐一检查所有自然数,对于每个整数,我们把所有的2、3和5的因子都除去,如果结果是1,则找到了一个丑数,当遇到第n= 1500个丑数时就找到答案了。1234567891011121314151617181920def valid(x): while x%2==0: x=x/2 while x%3==0: x=x/3 while x%5==0: x=x/5 if x==1: return 1 else: return 0def get_number(n): x=1 i=0 while(1): if valid(x): i=i+1 if i==n: return x x=x+1; 改进一我们的思路是先把1作为唯一的元素放入队列,然后我们不断从队列另一侧取出元素,分别乘以2、3和5,这样就得到了3个新的元素。然后把它们按照大小顺序放入队列。注意,这样产生的整数有可能已经在队列中存在了。这种情况下,我们需要丢弃重复产生的元素。另外新产生的整数还有可能小于队列尾部的某些元素,所以我们在插入时,需要保持它们在队列中的大小顺序。1234567891011121314151617181920212223int get_number(int n)&#123; queue&lt;int&gt; Q; int t; Q.push(1); while(n &gt; 0)&#123; t=Q.front(); Q.pop(); unique_enqueue(Q,2*t); unique_enqueue(Q,3*t); unique_enqueue(Q,4*t); n--; &#125;&#125;void unique_enqueue(queue&lt;int&gt; *Q, int x)&#123; int i = 0; while(i &lt; Q-&gt;size() &amp;&amp; Q[i] &lt; x)&#123; i++; &#125; if(i &lt; Q-&gt;size() &amp;&amp; Q[i]==x)&#123; return; &#125; insert(Q,i,x);&#125; 改进二我们可以用三个队列来进行改进。这三个队列表示为Q 2 ,Q 3 和Q 5 。它们初始化为Q 2 = {2},Q 3 = {3}和Q 5 = {5}。我们每次从这三个队列的头部选择最小的一个元素x取出,然后进行下面的检查: 如果x是从Q2取出的,我们将2x加入Q2 ,3x加入Q3 ,5x加入Q5。 如果x是从Q3取出的,我们只将3x加入Q3,5x加入Q5,而不需要将2x加入Q2。这是因为2x已经在Q3中了。 如果x是从Q5取出的,我们只将5x加入Q5 ,而不需要处理2x和3x了。 123456789101112131415161718192021222324252627typedef unsigned long Integer;Integer get_number(int n) &#123; if(n==1) return 1; queue&lt;Integer&gt; Q2, Q3, Q5; Q2.push(2); Q3.push(3); Q5.push(5); Integer x; while(n-- &gt; 1) &#123; x = min(min(Q2.front(), Q3.front()), Q5.front()); if(x==Q2.front()) &#123; Q2.pop(); Q2.push(x∗2); Q3.push(x∗3); Q5.push(x∗5); &#125; else if(x==Q3.front()) &#123; Q3.pop(); Q3.push(x∗3); Q5.push(x∗5); &#125; else &#123; Q5.pop(); Q5.push(x∗5); &#125; &#125; return x;&#125; 改进三首先，第一个丑数为“1”，后面的每一个丑数都是有前一个丑数乘2、3、5或7而来，那么后一个丑数就是前一个乘这四个数得到的最小值，for example：第一个：1，第二个：1*2、1*3、1*5或1*7，显然为2，第三个：2*2,1*3,1*5或1*7，显然是3，第四个：2*2,,2*3,1*5,1*7为4，第五个：3*2,2*3,1*5,1*7…… 1234567891011121314151617181920int a[5850];int main()&#123; int n=1; int p2,p3,p5; p2=p3=p5=1; a[1]=1; while(n&lt;5843)//枚举5842个丑数，放在数组a里。 &#123; a[++n]=min4(2*a[p2],3*a[p3],5*a[p5]);//从现在枚举的3个丑数里，先选择小的放在a里。 if(a[n]==2*a[p2])p2++;//如果a[n]==2*a[p2],2*a[p2]可能是吧a[n]枚举出的数，这样p2++,也可能是重复的枚举，这样也是p2++,总之p2++。 if(a[n]==3*a[p3])p3++;//同理。 if(a[n]==5*a[p5])p5++;//同理。 &#125; while(scanf("%d",&amp;n)&amp;&amp;n) &#123; printf("%d\n",a[n]);//要谁找谁。 &#125; return 0;&#125;]]></content>
      <categories>
        <category>初等算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偷影子的人]]></title>
    <url>%2F2017%2F04%2F03%2FLeVoleur%2F</url>
    <content type="text"><![CDATA[有些人只拥吻影子，于是只拥有幸福的幻影。—-莎士比亚 爱情里面最需要的，是想象力。每个人必须要用尽全力和全部的想象力来形塑对方，并丝毫不向现实低头。那么，当双方幻想相遇……就再也没有比这更美的景象了。—-罗曼.加里 &#160; &#160; &#160; &#160; 如果你能偷我的影子，那么我的影子会告诉你什么呢？ &#160; &#160; &#160; &#160; 在这本马克·李维的小说里面，讲述的就是这样的一个故事。一个老是受班上同学欺负的瘦弱小男孩，因为拥有一种特殊能力而强大：他能“偷别人的影子”，因而能看见他人心事，听见人们心中不愿意说出口的秘密。他开始成为需要帮助者的心灵伙伴，为每个偷来的影子找到点亮生命的小小光芒。某年灿烂的夏天，他在海边邂逅了一位又聋又哑的女孩。他该如何用自己的能力帮助她？他将如何信守与她共许的承诺？ &#160; &#160; &#160; &#160; 这是一部面向成人的童话，我们每一个人都能在里面找到自己的影子。在我们成长的青葱时光里，我们有过班级里面的死对头，一起在外面打过群架，去过脏兮兮的网吧通宵，一起去过山上摘果子，我们折过纸飞机，打过洋画，弹过弹珠。我们有吃过老干妈拌饭，去水库游泳，一起去书店买书。我们有过那些年一起追过的女孩，有那些一言不合就打架的同桌。 &#160; &#160; &#160; &#160; 我们也试过，和一个大朋友分享那些深埋在心里的小秘密，结识到一个看起来很滑稽的家伙，没想到很快成了死党。我们也记得，面对自己不能理解的感情的时候，心里那种纠结不安的情感，当家里有变故的时候，我们会想把自己缩的小小的，藏在一个别人都看不到的地方，我们不知不觉间，会把各种不属于自己的责任往自己身上背。但是又装的满不在乎，只好偷偷地在夜里，跟映在墙上的影子倾诉那些憋在心里的真心话。原来，影子在很早之前，就是我们信赖的朋友了，只是自己在长大之后，渐渐忘记了。马克•李维那一支生花妙笔，会让你想起，那些你以为遗忘了的前尘往事，和你自己不曾审视过的微妙情感。 &#160; &#160; &#160; &#160; 主人公不是拥有那些读心术语一样的特异功能。作者想告诉我们的是，只要我们用心去感受他人的情绪，设身处地的为朋友着想，我们也能够获得朋友的真心，就想读心术一样。我们也可以得到朋友的信任，用真心去换取真心。 &#160; &#160; &#160; &#160; 作者在文中对亲情的描述，可以让我们感受到一种缺憾美。在我们年轻的时候，我们哭着闹着想要离开这个名为象牙塔的地方，最终，如我们所愿，我们考上了大学，找到了一份满意的工作，我们是自由了，但是我们忘记了那个名叫老家的地方以及那里还有一个让在等着你。如果有一天，那个等你的人老了，不在了，我想你也就没有机会再回到从前了吧。我们每一个人的心中都充满这这种爱，但是我们都把它藏的密不透风，从来就没有表达出来。我们工作过后，有自己的生活，工作也很充实，更可以找到另一半。但是我们对父母的爱一直是没有挂心，我们表现的很粗心，毫不在意。从来就不关系自己的母亲的渐渐老去。我们知道很多朋友的秘密，却从来没有了解过自己父母的心。道理就是这样，我们要做的就是珍惜我们身边的人。 &#160; &#160; &#160; &#160; 爱情，是整个故事中的一抹亮色，爱情，会照亮我们每个人的生命。在很小的时候，偷影子的小男孩是怀疑爱情的，他曾经发出过疑问：“爱情，莫非像影子一样。有人踩中了，就带着离去？还是因为爱情跟影子一样怕光，又或者，情况正好相反，没有了光，爱情的影子就被拭去，最终黯然离去？”可是，当他遇到了克莱尔，遇到了苏菲。他开始涤清自己的恐惧，他的爱单纯美丽的像一个寓言。当他放弃了一个近在咫尺各方面都很般配的交往对象，去追逐一个童年就开始的梦，不再忧心得失的时候，他才领会了爱的真谛。那个让你舍弃了一切去追寻的，却充满了不确定性的人，才是你真正爱的人。无论过去了多少年，不管你已经变成了什么样子，就算所有景色都已经人事已非，我还是，最喜欢你。 &#160; &#160; &#160; &#160; 这才是真正的人生吧，在平淡的岁月里经历得失慢慢丰盈起来的人生，就好像，你我必将经历的人生一样。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心灵救赎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习]]></title>
    <url>%2F2017%2F04%2F03%2FmarkdownLearn%2F</url>
    <content type="text"><![CDATA[简书居然没有官方 Markdown 教程，我来写一个。原来官方是有的。。。献给写作者的 Markdown 新手指南。不过我这个更简，而且还有独门秘籍。 首先，“Markdown 其实很简单。在简书上学习 Markdown 最方便。” 1. 标题为了获得上面的 “1. 标题”， 在 Markdown 编辑器里输入： 1# 1. 标题 “#” 后最好加个空格。除此之外，还有 5 级标题，依次有不同的字体大小，即 12345## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 这样就有： 二级标题三级标题四级标题五级标题六级标题 2. 加粗，斜体最常用的强调方式，那就是 加粗 了，你得这样： 1最常用的强调方式，那就是 **加粗** 了，你得这样： 通常我喜欢在 “**加粗的部分**” 旁边各加一个空格，当然你也可以不这样。斜体则多用在于书名，比如：我从来没看过 Jane Eyre 1斜体则多用在于书名，比如：我从来没看过 *Jane Eyre* 但中文的斜体我觉得真是不美，像：《简 · 爱》，一般还是别用了。 3. 层次比如写个读书笔记，你得也不难：12345678#### 第一章1. 第一节* 第二节(你不用敲 &quot;2&quot;，自动就有了） * 第一小节（推荐每层次缩进四个空格） * 小小节 1 * 小小节 2 * 第二小节 “*” 后面要加空格，这是必须的，除了 *，还可以使用 + 或者 -。 如果格式出现问题，多加个空行，一般就好了。 4. 链接，图片你：我没读过 Jane Eyre我：以后别跟我说话！你：。。。我：我也没读过，但是， Jane Eyre is not just Jane Eyre 12我：我也没读过，但是， [***Jane Eyre***](http://book.douban.com/subject/1141406/) is not just ***Jane Eyre***![](markdownLearn/jianai.jpg) 5. 其他你可能还没注意到本文每部分之间的分割线和 其他 的链接其实没有链接我爱 分割线， 我爱 链接，哪怕它只有颜色~ 12345678---# [5. 其他][null-link]你可能还没注意到本文每部分之间的分割线和 `其他` 的链接其实没有链接我爱 `分割线`， 我爱 [**链接**][null-link]，哪怕它只有颜色~[null-link]: chrome://not-a-link “---” 的上下最好各空一行 P.S. 补充一种高端的链接: [鼠标移过来，先别单击 ~][hover][hover]: http://www.google.com.sg “Google Sg 更快，更好用。好，现在单击吧” 代码如下： 12**P.S.** 补充一种高端的链接: [鼠标移过来，**先别单击** ~][hover][hover]: http://www.google.com.sg &quot;Google Sg 更快，更好用。好，现在单击吧&quot; （可惜 Google 被墙了） P.P.S. 图片链接：(点击图片可跳转）[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ 代码如下：123[![][jane-eyre-pic]][jane-eyre-douban][jane-eyre-pic]: http://img3.douban.com/mpic/s1108264.jpg[jane-eyre-douban]: http://book.douban.com/subject/1141406/ （简书最新的 Markdown 不能使用图片链接。。。感受不爱）P.P.P.S. 更多的 Markdown 特性测试，见我的 Markdown 一篇博客 在简书中输入数学公式：见我的 简书中编辑数学公式 如何写出漂亮的 Markdown 文章？戳 Markdown 写作规范参考]]></content>
      <categories>
        <category>MD学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
